// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by protocols/vulkan/xml/genvk.py -registry protocols/vulkan/xml/vk.xml cereal -o stream-servers/vulkan/cereal
// Please do not modify directly;
// re-run generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"
#include "common/goldfish_vk_reserved_marshaling.h"
#include "common/goldfish_vk_private_defs.h"
#include "common/goldfish_vk_transform.h"

#include "base/BumpPool.h"
#include "base/System.h"
#include "base/Tracing.h"
#include "stream-servers/IOStream.h"
#include "host-common/feature_control.h"
#include "host-common/logging.h"

#include "VkDecoderGlobalState.h"
#include "VkDecoderSnapshot.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>





using emugl::vkDispatch;

using namespace goldfish_vk;

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(android::base::getEnvironmentVariable("ANDROID_EMU_VK_LOG_CALLS") == "1"),
             m_vk(vkDispatch()),
             m_state(VkDecoderGlobalState::get()),
             m_boxedHandleUnwrapMapping(m_state),
             m_boxedHandleCreateMapping(m_state),
             m_boxedHandleDestroyMapping(m_state),
             m_boxedHandleUnwrapAndDeleteMapping(m_state),
             m_boxedHandleUnwrapAndDeletePreserveBoxedMapping(m_state) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    void setForSnapshotLoad(bool forSnapshotLoad) {
        m_forSnapshotLoad = forSnapshotLoad;
    }

    size_t decode(void* buf, size_t bufsize, IOStream* stream, uint32_t* seqnoPtr);

private:
    bool m_logCalls;
    bool m_forSnapshotLoad = false;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
    BoxedHandleCreateMapping m_boxedHandleCreateMapping;
    BoxedHandleDestroyMapping m_boxedHandleDestroyMapping;
    BoxedHandleUnwrapAndDeleteMapping m_boxedHandleUnwrapAndDeleteMapping;
    android::base::BumpPool m_pool;
    BoxedHandleUnwrapAndDeletePreserveBoxedMapping m_boxedHandleUnwrapAndDeletePreserveBoxedMapping;
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()) { }

VkDecoder::~VkDecoder() = default;

void VkDecoder::setForSnapshotLoad(bool forSnapshotLoad) {
    mImpl->setForSnapshotLoad(forSnapshotLoad);
}

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* stream, uint32_t* seqnoPtr) {
    return mImpl->decode(buf, bufsize, stream, seqnoPtr);
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream, uint32_t* seqnoPtr)
{
    if (len < 8) return 0;;
    bool queueSubmitWithCommandsEnabled = feature_is_enabled(kFeature_VulkanQueueSubmitWithCommands);
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    if (m_forSnapshotLoad)
    {
        ptr += m_state->setCreatedHandlesForSnapshotLoad(ptr);
    }
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        uint8_t* readStreamPtr = vkReadStream->getBuf(); uint8_t** readStreamPtrPtr = &readStreamPtr;
        uint8_t* snapshotTraceBegin = vkReadStream->beginTrace();
        vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
        
                 if (queueSubmitWithCommandsEnabled && opcode >= OP_vkCreateInstance && opcode < OP_vkLast) {
            uint32_t seqno; memcpy(&seqno, *readStreamPtrPtr, sizeof(uint32_t)); *readStreamPtrPtr += sizeof(uint32_t);
            if (seqnoPtr && !m_forSnapshotLoad) {
                while ((seqno - __atomic_load_n(seqnoPtr, __ATOMIC_SEQ_CST) != 1));
            }
        }
        
        auto vk = m_vk;
        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                android::base::beginTrace("vkCreateInstance decode");
                const VkInstanceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                reservedunmarshal_VkInstanceCreateInfo(vkReadStream, (VkInstanceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pInstance;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkInstance*)pInstance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_1));
                if (pCreateInfo)
                {
                    transform_tohost_VkInstanceCreateInfo(m_state, (VkInstanceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateInstance 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pInstance);
                }
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(&m_pool, pCreateInfo, pAllocator, pInstance);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                static_assert(8 == sizeof(VkInstance), "handle map overwrite requires VkInstance to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkInstance((VkInstance*)pInstance, 1);
                vkStream->write((VkInstance*)pInstance, 8 * 1);
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyInstance:
            {
                android::base::beginTrace("vkDestroyInstance decode");
                VkInstance instance;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_3));
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyInstance 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyInstance(&m_pool, instance, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                android::base::beginTrace("vkEnumeratePhysicalDevices decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                // Begin global wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_5;
                memcpy((uint64_t*)&cgen_var_5, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_5));
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDevices;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDevice**)&pPhysicalDevices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDevices);
                *readStreamPtrPtr += 8;
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint8_t* cgen_var_8_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pPhysicalDeviceCount));
                        for (uint32_t k = 0; k < (*(pPhysicalDeviceCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_8_ptr + k * 8, sizeof(uint64_t));
                            *(((VkPhysicalDevice*)pPhysicalDevices) + k) = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)tmpval);
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDevices 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceCount, (unsigned long long)pPhysicalDevices);
                }
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_state->on_vkEnumeratePhysicalDevices(&m_pool, instance, pPhysicalDeviceCount, pPhysicalDevices);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_9 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
                vkStream->putBe64(cgen_var_9);
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDevices;
                vkStream->putBe64(cgen_var_10);
                if (pPhysicalDevices)
                {
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_11;
                        vkStream->alloc((void**)&cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                        static_assert(8 == sizeof(VkPhysicalDevice), "handle map overwrite requires VkPhysicalDevice to be 8 bytes long");
                        vkStream->handleMapping()->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                        vkStream->write((VkPhysicalDevice*)pPhysicalDevices, 8 * (*(pPhysicalDeviceCount)));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDevices(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDevices_VkResult_return, instance, pPhysicalDeviceCount, pPhysicalDevices);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_12;
                memcpy((uint64_t*)&cgen_var_12, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_12));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                reservedunmarshal_VkPhysicalDeviceFeatures(vkReadStream, (VkPhysicalDeviceFeatures*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_13;
                memcpy((uint64_t*)&cgen_var_13, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_13));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                reservedunmarshal_VkFormatProperties(vkReadStream, (VkFormatProperties*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_14;
                memcpy((uint64_t*)&cgen_var_14, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_14));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageCreateFlags*)&flags, *readStreamPtrPtr, sizeof(VkImageCreateFlags));
                *readStreamPtrPtr += sizeof(VkImageCreateFlags);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                reservedunmarshal_VkImageFormatProperties(vkReadStream, (VkImageFormatProperties*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties(&m_pool, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties_VkResult_return, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_15;
                memcpy((uint64_t*)&cgen_var_15, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_15));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                reservedunmarshal_VkPhysicalDeviceProperties(vkReadStream, (VkPhysicalDeviceProperties*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_16;
                memcpy((uint64_t*)&cgen_var_16, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_16));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties(vkReadStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_19 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_19);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_20 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_20);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_21;
                memcpy((uint64_t*)&cgen_var_21, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_21));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                android::base::beginTrace("vkGetInstanceProcAddr decode");
                VkInstance instance;
                const char* pName;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_22;
                memcpy((uint64_t*)&cgen_var_22, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_22));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pName, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetInstanceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = vk->vkGetInstanceProcAddr(unboxed_instance, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetInstanceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetInstanceProcAddr_PFN_vkVoidFunction_return, instance, pName);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                android::base::beginTrace("vkGetDeviceProcAddr decode");
                VkDevice device;
                const char* pName;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_23;
                memcpy((uint64_t*)&cgen_var_23, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_23));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pName, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = vk->vkGetDeviceProcAddr(unboxed_device, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceProcAddr_PFN_vkVoidFunction_return, device, pName);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDevice:
            {
                android::base::beginTrace("vkCreateDevice decode");
                VkPhysicalDevice physicalDevice;
                const VkDeviceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_24;
                memcpy((uint64_t*)&cgen_var_24, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_24));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                reservedunmarshal_VkDeviceCreateInfo(vkReadStream, (VkDeviceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                uint64_t cgen_var_26;
                memcpy((uint64_t*)&cgen_var_26, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDevice*)pDevice = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_26));
                if (pCreateInfo)
                {
                    transform_tohost_VkDeviceCreateInfo(m_state, (VkDeviceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDevice 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDevice);
                }
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(&m_pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_27;
                static_assert(8 == sizeof(VkDevice), "handle map overwrite requires VkDevice to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDevice((VkDevice*)pDevice, 1);
                vkStream->write((VkDevice*)pDevice, 8 * 1);
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDevice:
            {
                android::base::beginTrace("vkDestroyDevice decode");
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_28;
                memcpy((uint64_t*)&cgen_var_28, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_28));
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDevice 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDevice(&m_pool, device, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                android::base::beginTrace("vkEnumerateInstanceExtensionProperties decode");
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    memcpy((char**)&pLayerName, (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&pLayerName);
                    *readStreamPtrPtr += 8;
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkExtensionProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceExtensionProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_33);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_34 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_34);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceExtensionProperties_VkResult_return, pLayerName, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                android::base::beginTrace("vkEnumerateDeviceExtensionProperties decode");
                VkPhysicalDevice physicalDevice;
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_35;
                memcpy((uint64_t*)&cgen_var_35, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_35));
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    memcpy((char**)&pLayerName, (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&pLayerName);
                    *readStreamPtrPtr += 8;
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkExtensionProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateDeviceExtensionProperties 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = m_state->on_vkEnumerateDeviceExtensionProperties(&m_pool, physicalDevice, pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_39 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_39);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_40 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_40);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceExtensionProperties_VkResult_return, physicalDevice, pLayerName, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                android::base::beginTrace("vkEnumerateInstanceLayerProperties decode");
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkLayerProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceLayerProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_43 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_43);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_44 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_44);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceLayerProperties_VkResult_return, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                android::base::beginTrace("vkEnumerateDeviceLayerProperties decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_45;
                memcpy((uint64_t*)&cgen_var_45, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_45));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkLayerProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateDeviceLayerProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_48 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_48);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_49 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_49);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceLayerProperties_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                android::base::beginTrace("vkGetDeviceQueue decode");
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_50;
                memcpy((uint64_t*)&cgen_var_50, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_50));
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queueIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_51;
                memcpy((uint64_t*)&cgen_var_51, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueue*)pQueue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_51));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceQueue 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queueFamilyIndex, (unsigned long long)queueIndex, (unsigned long long)pQueue);
                }
                m_state->on_vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_52;
                static_assert(8 == sizeof(VkQueue), "handle map overwrite requires VkQueue to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueue((VkQueue*)pQueue, 1);
                vkStream->write((VkQueue*)pQueue, 8 * 1);
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSubmit:
            {
                android::base::beginTrace("vkQueueSubmit decode");
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_53;
                memcpy((uint64_t*)&cgen_var_53, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_53));
                memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    reservedunmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_54;
                memcpy((uint64_t*)&cgen_var_54, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_54));
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSubmit 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)submitCount, (unsigned long long)pSubmits, (unsigned long long)fence);
                }
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSubmit(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSubmit_VkResult_return, queue, submitCount, pSubmits, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                android::base::beginTrace("vkQueueWaitIdle decode");
                VkQueue queue;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_55;
                memcpy((uint64_t*)&cgen_var_55, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_55));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueWaitIdle 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = m_state->on_vkQueueWaitIdle(&m_pool, queue);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueWaitIdle_VkResult_return, queue);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                android::base::beginTrace("vkDeviceWaitIdle decode");
                VkDevice device;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_56;
                memcpy((uint64_t*)&cgen_var_56, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_56));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDeviceWaitIdle 0x%llx \n", ioStream, (unsigned long long)device);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDeviceWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDeviceWaitIdle_VkResult_return, device);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateMemory:
            {
                android::base::beginTrace("vkAllocateMemory decode");
                VkDevice device;
                const VkMemoryAllocateInfo* pAllocateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_57;
                memcpy((uint64_t*)&cgen_var_57, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_57));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                reservedunmarshal_VkMemoryAllocateInfo(vkReadStream, (VkMemoryAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMemory;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                uint64_t cgen_var_59;
                memcpy((uint64_t*)&cgen_var_59, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDeviceMemory*)pMemory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_59));
                if (pAllocateInfo)
                {
                    transform_tohost_VkMemoryAllocateInfo(m_state, (VkMemoryAllocateInfo*)(pAllocateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pAllocator, (unsigned long long)pMemory);
                }
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(&m_pool, device, pAllocateInfo, pAllocator, pMemory);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_60;
                static_assert(8 == sizeof(VkDeviceMemory), "handle map overwrite requires VkDeviceMemory to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)pMemory, 1);
                vkStream->write((VkDeviceMemory*)pMemory, 8 * 1);
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateMemory_VkResult_return, device, pAllocateInfo, pAllocator, pMemory);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeMemory:
            {
                android::base::beginTrace("vkFreeMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_61;
                memcpy((uint64_t*)&cgen_var_61, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_61));
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory boxed_memory_preserve;
                uint64_t cgen_var_62;
                memcpy((uint64_t*)&cgen_var_62, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_62));
                boxed_memory_preserve = memory;
                memory = unbox_VkDeviceMemory(memory);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeMemory 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                m_state->on_vkFreeMemory(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_memory_preserve, pAllocator);
                }
                delete_VkDeviceMemory(boxed_memory_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMapMemory:
            {
                android::base::beginTrace("vkMapMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_64;
                memcpy((uint64_t*)&cgen_var_64, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_64));
                uint64_t cgen_var_65;
                memcpy((uint64_t*)&cgen_var_65, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_65));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkMemoryMapFlags*)&flags, *readStreamPtrPtr, sizeof(VkMemoryMapFlags));
                *readStreamPtrPtr += sizeof(VkMemoryMapFlags);
                // Begin manual dispatchable handle unboxing for ppData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void***)&ppData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&ppData);
                *readStreamPtrPtr += 8;
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    memcpy((void**)ppData, *readStreamPtrPtr, sizeof(void*));
                    *readStreamPtrPtr += sizeof(void*);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMapMemory 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)flags, (unsigned long long)ppData);
                }
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(&m_pool, device, memory, offset, size, flags, ppData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_67 = (uint64_t)(uintptr_t)ppData;
                vkStream->putBe64(cgen_var_67);
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemory_VkResult_return, device, memory, offset, size, flags, ppData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUnmapMemory:
            {
                android::base::beginTrace("vkUnmapMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_68;
                memcpy((uint64_t*)&cgen_var_68, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_68));
                uint64_t cgen_var_69;
                memcpy((uint64_t*)&cgen_var_69, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_69));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUnmapMemory 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory);
                }
                m_state->on_vkUnmapMemory(&m_pool, device, memory);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUnmapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                android::base::beginTrace("vkFlushMappedMemoryRanges decode");
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_70;
                memcpy((uint64_t*)&cgen_var_70, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_70));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&memoryRangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    reservedunmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i), readStreamPtrPtr);
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFlushMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = pMemoryRanges[i].memory;
                        auto size = pMemoryRanges[i].size;
                        auto offset = pMemoryRanges[i].offset;
                        uint64_t readStream = 0;
                        memcpy(&readStream, *readStreamPtrPtr, sizeof(uint64_t)); *readStreamPtrPtr += sizeof(uint64_t);
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        if (!hostPtr && readStream > 0) abort();
                        if (!hostPtr) continue;
                        uint8_t* targetRange = hostPtr + offset;
                        memcpy(targetRange, *readStreamPtrPtr, readStream); *readStreamPtrPtr += readStream;
                    }
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = vk->vkFlushMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFlushMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFlushMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                android::base::beginTrace("vkInvalidateMappedMemoryRanges decode");
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_71;
                memcpy((uint64_t*)&cgen_var_71, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_71));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&memoryRangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    reservedunmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i), readStreamPtrPtr);
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkInvalidateMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = vk->vkInvalidateMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = range.memory;
                        auto size = range.size;
                        auto offset = range.offset;
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                        uint64_t writeStream = 0;
                        if (!hostPtr) { vkStream->write(&writeStream, sizeof(uint64_t)); continue; };
                        uint8_t* targetRange = hostPtr + offset;
                        writeStream = actualSize;
                        vkStream->write(&writeStream, sizeof(uint64_t));
                        vkStream->write(targetRange, actualSize);
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkInvalidateMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkInvalidateMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                android::base::beginTrace("vkGetDeviceMemoryCommitment decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_72;
                memcpy((uint64_t*)&cgen_var_72, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_72));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_73;
                memcpy((uint64_t*)&cgen_var_73, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_73));
                // Begin manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pCommittedMemoryInBytes, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceMemoryCommitment 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pCommittedMemoryInBytes);
                }
                vk->vkGetDeviceMemoryCommitment(unboxed_device, memory, pCommittedMemoryInBytes);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceMemoryCommitment(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory, pCommittedMemoryInBytes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindBufferMemory:
            {
                android::base::beginTrace("vkBindBufferMemory decode");
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_74;
                memcpy((uint64_t*)&cgen_var_74, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_74));
                uint64_t cgen_var_75;
                memcpy((uint64_t*)&cgen_var_75, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_75));
                uint64_t cgen_var_76;
                memcpy((uint64_t*)&cgen_var_76, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_76));
                memcpy((VkDeviceSize*)&memoryOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(&m_pool, device, buffer, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory_VkResult_return, device, buffer, memory, memoryOffset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory:
            {
                android::base::beginTrace("vkBindImageMemory decode");
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_77;
                memcpy((uint64_t*)&cgen_var_77, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_77));
                uint64_t cgen_var_78;
                memcpy((uint64_t*)&cgen_var_78, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_78));
                uint64_t cgen_var_79;
                memcpy((uint64_t*)&cgen_var_79, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_79));
                memcpy((VkDeviceSize*)&memoryOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_state->on_vkBindImageMemory(&m_pool, device, image, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory_VkResult_return, device, image, memory, memoryOffset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements decode");
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_80;
                memcpy((uint64_t*)&cgen_var_80, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_80));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_81;
                memcpy((uint64_t*)&cgen_var_81, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_81));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements(unboxed_device, buffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, buffer, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements decode");
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_82;
                memcpy((uint64_t*)&cgen_var_82, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_82));
                uint64_t cgen_var_83;
                memcpy((uint64_t*)&cgen_var_83, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_83));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements(&m_pool, device, image, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements decode");
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_84;
                memcpy((uint64_t*)&cgen_var_84, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_84));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_85;
                memcpy((uint64_t*)&cgen_var_85, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_85));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements(vkReadStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements(unboxed_device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_88 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_88);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_89 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_89);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_90;
                memcpy((uint64_t*)&cgen_var_90, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_90));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkSampleCountFlagBits*)&samples, *readStreamPtrPtr, sizeof(VkSampleCountFlagBits));
                *readStreamPtrPtr += sizeof(VkSampleCountFlagBits);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties(vkReadStream, (VkSparseImageFormatProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)samples, (unsigned long long)usage, (unsigned long long)tiling, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties(unboxed_physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_93 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_93);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_94 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_94);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBindSparse:
            {
                android::base::beginTrace("vkQueueBindSparse decode");
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_95;
                memcpy((uint64_t*)&cgen_var_95, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_95));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_96;
                memcpy((uint64_t*)&cgen_var_96, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_96));
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBindSparse 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfo, (unsigned long long)fence);
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = vk->vkQueueBindSparse(unboxed_queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBindSparse(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueBindSparse_VkResult_return, queue, bindInfoCount, pBindInfo, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateFence:
            {
                android::base::beginTrace("vkCreateFence decode");
                VkDevice device;
                const VkFenceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_97;
                memcpy((uint64_t*)&cgen_var_97, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_97));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                reservedunmarshal_VkFenceCreateInfo(vkReadStream, (VkFenceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_99;
                memcpy((uint64_t*)&cgen_var_99, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_99));
                if (pCreateInfo)
                {
                    transform_tohost_VkFenceCreateInfo(m_state, (VkFenceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateFence 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = vk->vkCreateFence(unboxed_device, pCreateInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFence;
                if (vkCreateFence_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_100;
                static_assert(8 == sizeof(VkFence), "handle map overwrite requires VkFence to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFence((VkFence*)pFence, 1);
                vkStream->write((VkFence*)pFence, 8 * 1);
                // Begin auto non dispatchable handle create for pFence;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFence_VkResult_return, device, pCreateInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyFence:
            {
                android::base::beginTrace("vkDestroyFence decode");
                VkDevice device;
                VkFence fence;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_101;
                memcpy((uint64_t*)&cgen_var_101, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_101));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for fence;
                VkFence boxed_fence_preserve;
                uint64_t cgen_var_102;
                memcpy((uint64_t*)&cgen_var_102, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)(VkFence)((VkFence)(*&cgen_var_102));
                boxed_fence_preserve = fence;
                fence = unbox_VkFence(fence);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyFence 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence, (unsigned long long)pAllocator);
                }
                vk->vkDestroyFence(unboxed_device, fence, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_fence_preserve, pAllocator);
                }
                delete_VkFence(boxed_fence_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetFences:
            {
                android::base::beginTrace("vkResetFences decode");
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_104;
                memcpy((uint64_t*)&cgen_var_104, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_104));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint8_t* cgen_var_105_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((fenceCount));
                    for (uint32_t k = 0; k < ((fenceCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_105_ptr + k * 8, sizeof(uint64_t));
                        *(((VkFence*)pFences) + k) = (VkFence)unbox_VkFence((VkFence)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetFences 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences);
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = vk->vkResetFences(unboxed_device, fenceCount, pFences);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetFences_VkResult_return, device, fenceCount, pFences);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceStatus:
            {
                android::base::beginTrace("vkGetFenceStatus decode");
                VkDevice device;
                VkFence fence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_106;
                memcpy((uint64_t*)&cgen_var_106, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_106));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_107;
                memcpy((uint64_t*)&cgen_var_107, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_107));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence);
                }
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = vk->vkGetFenceStatus(unboxed_device, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceStatus_VkResult_return, device, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkWaitForFences:
            {
                android::base::beginTrace("vkWaitForFences decode");
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_108;
                memcpy((uint64_t*)&cgen_var_108, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_108));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint8_t* cgen_var_109_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((fenceCount));
                    for (uint32_t k = 0; k < ((fenceCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_109_ptr + k * 8, sizeof(uint64_t));
                        *(((VkFence*)pFences) + k) = (VkFence)unbox_VkFence((VkFence)tmpval);
                    }
                }
                memcpy((VkBool32*)&waitAll, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkWaitForFences 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences, (unsigned long long)waitAll, (unsigned long long)timeout);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWaitForFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWaitForFences_VkResult_return, device, fenceCount, pFences, waitAll, timeout);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSemaphore:
            {
                android::base::beginTrace("vkCreateSemaphore decode");
                VkDevice device;
                const VkSemaphoreCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_110;
                memcpy((uint64_t*)&cgen_var_110, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_110));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                reservedunmarshal_VkSemaphoreCreateInfo(vkReadStream, (VkSemaphoreCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSemaphore;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                uint64_t cgen_var_112;
                memcpy((uint64_t*)&cgen_var_112, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSemaphore*)pSemaphore = (VkSemaphore)(VkSemaphore)((VkSemaphore)(*&cgen_var_112));
                if (pCreateInfo)
                {
                    transform_tohost_VkSemaphoreCreateInfo(m_state, (VkSemaphoreCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSemaphore 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSemaphore);
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(&m_pool, device, pCreateInfo, pAllocator, pSemaphore);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_113;
                static_assert(8 == sizeof(VkSemaphore), "handle map overwrite requires VkSemaphore to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSemaphore((VkSemaphore*)pSemaphore, 1);
                vkStream->write((VkSemaphore*)pSemaphore, 8 * 1);
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSemaphore_VkResult_return, device, pCreateInfo, pAllocator, pSemaphore);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySemaphore:
            {
                android::base::beginTrace("vkDestroySemaphore decode");
                VkDevice device;
                VkSemaphore semaphore;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_114;
                memcpy((uint64_t*)&cgen_var_114, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_114));
                // Begin manual non dispatchable handle destroy unboxing for semaphore;
                VkSemaphore boxed_semaphore_preserve;
                uint64_t cgen_var_115;
                memcpy((uint64_t*)&cgen_var_115, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)(VkSemaphore)((VkSemaphore)(*&cgen_var_115));
                boxed_semaphore_preserve = semaphore;
                semaphore = unbox_VkSemaphore(semaphore);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySemaphore 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)semaphore, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_semaphore_preserve, pAllocator);
                }
                delete_VkSemaphore(boxed_semaphore_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateEvent:
            {
                android::base::beginTrace("vkCreateEvent decode");
                VkDevice device;
                const VkEventCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_117;
                memcpy((uint64_t*)&cgen_var_117, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_117));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                reservedunmarshal_VkEventCreateInfo(vkReadStream, (VkEventCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pEvent;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                uint64_t cgen_var_119;
                memcpy((uint64_t*)&cgen_var_119, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkEvent*)pEvent = (VkEvent)(VkEvent)((VkEvent)(*&cgen_var_119));
                if (pCreateInfo)
                {
                    transform_tohost_VkEventCreateInfo(m_state, (VkEventCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateEvent 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pEvent);
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pEvent;
                if (vkCreateEvent_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_120;
                static_assert(8 == sizeof(VkEvent), "handle map overwrite requires VkEvent to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkEvent((VkEvent*)pEvent, 1);
                vkStream->write((VkEvent*)pEvent, 8 * 1);
                // Begin auto non dispatchable handle create for pEvent;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateEvent_VkResult_return, device, pCreateInfo, pAllocator, pEvent);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyEvent:
            {
                android::base::beginTrace("vkDestroyEvent decode");
                VkDevice device;
                VkEvent event;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_121;
                memcpy((uint64_t*)&cgen_var_121, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_121));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for event;
                VkEvent boxed_event_preserve;
                uint64_t cgen_var_122;
                memcpy((uint64_t*)&cgen_var_122, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)(VkEvent)((VkEvent)(*&cgen_var_122));
                boxed_event_preserve = event;
                event = unbox_VkEvent(event);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event, (unsigned long long)pAllocator);
                }
                vk->vkDestroyEvent(unboxed_device, event, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_event_preserve, pAllocator);
                }
                delete_VkEvent(boxed_event_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetEventStatus:
            {
                android::base::beginTrace("vkGetEventStatus decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_124;
                memcpy((uint64_t*)&cgen_var_124, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_124));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_125;
                memcpy((uint64_t*)&cgen_var_125, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_125));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetEventStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetEventStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetEventStatus_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetEvent:
            {
                android::base::beginTrace("vkSetEvent decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_126;
                memcpy((uint64_t*)&cgen_var_126, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_126));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_127;
                memcpy((uint64_t*)&cgen_var_127, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_127));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetEvent_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetEvent:
            {
                android::base::beginTrace("vkResetEvent decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_128;
                memcpy((uint64_t*)&cgen_var_128, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_128));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_129;
                memcpy((uint64_t*)&cgen_var_129, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_129));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetEvent_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateQueryPool:
            {
                android::base::beginTrace("vkCreateQueryPool decode");
                VkDevice device;
                const VkQueryPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_130;
                memcpy((uint64_t*)&cgen_var_130, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_130));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                reservedunmarshal_VkQueryPoolCreateInfo(vkReadStream, (VkQueryPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pQueryPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                uint64_t cgen_var_132;
                memcpy((uint64_t*)&cgen_var_132, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueryPool*)pQueryPool = (VkQueryPool)(VkQueryPool)((VkQueryPool)(*&cgen_var_132));
                if (pCreateInfo)
                {
                    transform_tohost_VkQueryPoolCreateInfo(m_state, (VkQueryPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pQueryPool);
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pQueryPool;
                if (vkCreateQueryPool_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_133;
                static_assert(8 == sizeof(VkQueryPool), "handle map overwrite requires VkQueryPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueryPool((VkQueryPool*)pQueryPool, 1);
                vkStream->write((VkQueryPool*)pQueryPool, 8 * 1);
                // Begin auto non dispatchable handle create for pQueryPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateQueryPool_VkResult_return, device, pCreateInfo, pAllocator, pQueryPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                android::base::beginTrace("vkDestroyQueryPool decode");
                VkDevice device;
                VkQueryPool queryPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_134;
                memcpy((uint64_t*)&cgen_var_134, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_134));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for queryPool;
                VkQueryPool boxed_queryPool_preserve;
                uint64_t cgen_var_135;
                memcpy((uint64_t*)&cgen_var_135, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)(VkQueryPool)((VkQueryPool)(*&cgen_var_135));
                boxed_queryPool_preserve = queryPool;
                queryPool = unbox_VkQueryPool(queryPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyQueryPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)pAllocator);
                }
                vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_queryPool_preserve, pAllocator);
                }
                delete_VkQueryPool(boxed_queryPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                android::base::beginTrace("vkGetQueryPoolResults decode");
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_137;
                memcpy((uint64_t*)&cgen_var_137, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_137));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_138;
                memcpy((uint64_t*)&cgen_var_138, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_138));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                memcpy((VkDeviceSize*)&stride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                *readStreamPtrPtr += sizeof(VkQueryResultFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dataSize, (unsigned long long)pData, (unsigned long long)stride, (unsigned long long)flags);
                }
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetQueryPoolResults_VkResult_return, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBuffer:
            {
                android::base::beginTrace("vkCreateBuffer decode");
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_140;
                memcpy((uint64_t*)&cgen_var_140, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_140));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                reservedunmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_142;
                memcpy((uint64_t*)&cgen_var_142, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBuffer*)pBuffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_142));
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer);
                }
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(&m_pool, device, pCreateInfo, pAllocator, pBuffer);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_143;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requires VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBuffer_VkResult_return, device, pCreateInfo, pAllocator, pBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyBuffer:
            {
                android::base::beginTrace("vkDestroyBuffer decode");
                VkDevice device;
                VkBuffer buffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_144;
                memcpy((uint64_t*)&cgen_var_144, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_144));
                // Begin manual non dispatchable handle destroy unboxing for buffer;
                VkBuffer boxed_buffer_preserve;
                uint64_t cgen_var_145;
                memcpy((uint64_t*)&cgen_var_145, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_145));
                boxed_buffer_preserve = buffer;
                buffer = unbox_VkBuffer(buffer);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyBuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_buffer_preserve, pAllocator);
                }
                delete_VkBuffer(boxed_buffer_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBufferView:
            {
                android::base::beginTrace("vkCreateBufferView decode");
                VkDevice device;
                const VkBufferViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_147;
                memcpy((uint64_t*)&cgen_var_147, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_147));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                reservedunmarshal_VkBufferViewCreateInfo(vkReadStream, (VkBufferViewCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                uint64_t cgen_var_149;
                memcpy((uint64_t*)&cgen_var_149, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBufferView*)pView = (VkBufferView)(VkBufferView)((VkBufferView)(*&cgen_var_149));
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferViewCreateInfo(m_state, (VkBufferViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBufferView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pView;
                if (vkCreateBufferView_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_150;
                static_assert(8 == sizeof(VkBufferView), "handle map overwrite requires VkBufferView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBufferView((VkBufferView*)pView, 1);
                vkStream->write((VkBufferView*)pView, 8 * 1);
                // Begin auto non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyBufferView:
            {
                android::base::beginTrace("vkDestroyBufferView decode");
                VkDevice device;
                VkBufferView bufferView;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_151;
                memcpy((uint64_t*)&cgen_var_151, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_151));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for bufferView;
                VkBufferView boxed_bufferView_preserve;
                uint64_t cgen_var_152;
                memcpy((uint64_t*)&cgen_var_152, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBufferView*)&bufferView = (VkBufferView)(VkBufferView)((VkBufferView)(*&cgen_var_152));
                boxed_bufferView_preserve = bufferView;
                bufferView = unbox_VkBufferView(bufferView);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyBufferView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bufferView, (unsigned long long)pAllocator);
                }
                vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_bufferView_preserve, pAllocator);
                }
                delete_VkBufferView(boxed_bufferView_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateImage:
            {
                android::base::beginTrace("vkCreateImage decode");
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_154;
                memcpy((uint64_t*)&cgen_var_154, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_154));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                reservedunmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_156;
                memcpy((uint64_t*)&cgen_var_156, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImage*)pImage = (VkImage)(VkImage)((VkImage)(*&cgen_var_156));
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImage 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage);
                }
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_state->on_vkCreateImage(&m_pool, device, pCreateInfo, pAllocator, pImage);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_157;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requires VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImage_VkResult_return, device, pCreateInfo, pAllocator, pImage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyImage:
            {
                android::base::beginTrace("vkDestroyImage decode");
                VkDevice device;
                VkImage image;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_158;
                memcpy((uint64_t*)&cgen_var_158, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_158));
                // Begin manual non dispatchable handle destroy unboxing for image;
                VkImage boxed_image_preserve;
                uint64_t cgen_var_159;
                memcpy((uint64_t*)&cgen_var_159, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)(VkImage)((VkImage)(*&cgen_var_159));
                boxed_image_preserve = image;
                image = unbox_VkImage(image);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyImage 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImage(&m_pool, device, image, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_image_preserve, pAllocator);
                }
                delete_VkImage(boxed_image_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                android::base::beginTrace("vkGetImageSubresourceLayout decode");
                VkDevice device;
                VkImage image;
                const VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_161;
                memcpy((uint64_t*)&cgen_var_161, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_161));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_162;
                memcpy((uint64_t*)&cgen_var_162, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_162));
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                reservedunmarshal_VkImageSubresource(vkReadStream, (VkImageSubresource*)(pSubresource), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                reservedunmarshal_VkSubresourceLayout(vkReadStream, (VkSubresourceLayout*)(pLayout), readStreamPtrPtr);
                if (pSubresource)
                {
                    transform_tohost_VkImageSubresource(m_state, (VkImageSubresource*)(pSubresource));
                }
                if (pLayout)
                {
                    transform_tohost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSubresourceLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSubresource, (unsigned long long)pLayout);
                }
                vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
                vkStream->unsetHandleMapping();
                if (pLayout)
                {
                    transform_fromhost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSubresourceLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSubresource, pLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateImageView:
            {
                android::base::beginTrace("vkCreateImageView decode");
                VkDevice device;
                const VkImageViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_163;
                memcpy((uint64_t*)&cgen_var_163, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_163));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                reservedunmarshal_VkImageViewCreateInfo(vkReadStream, (VkImageViewCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                uint64_t cgen_var_165;
                memcpy((uint64_t*)&cgen_var_165, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImageView*)pView = (VkImageView)(VkImageView)((VkImageView)(*&cgen_var_165));
                if (pCreateInfo)
                {
                    transform_tohost_VkImageViewCreateInfo(m_state, (VkImageViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImageView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(&m_pool, device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pView;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_166;
                static_assert(8 == sizeof(VkImageView), "handle map overwrite requires VkImageView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImageView((VkImageView*)pView, 1);
                vkStream->write((VkImageView*)pView, 8 * 1);
                // Begin manual non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyImageView:
            {
                android::base::beginTrace("vkDestroyImageView decode");
                VkDevice device;
                VkImageView imageView;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_167;
                memcpy((uint64_t*)&cgen_var_167, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_167));
                // Begin manual non dispatchable handle destroy unboxing for imageView;
                VkImageView boxed_imageView_preserve;
                uint64_t cgen_var_168;
                memcpy((uint64_t*)&cgen_var_168, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImageView*)&imageView = (VkImageView)(VkImageView)((VkImageView)(*&cgen_var_168));
                boxed_imageView_preserve = imageView;
                imageView = unbox_VkImageView(imageView);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyImageView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)imageView, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImageView(&m_pool, device, imageView, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_imageView_preserve, pAllocator);
                }
                delete_VkImageView(boxed_imageView_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateShaderModule:
            {
                android::base::beginTrace("vkCreateShaderModule decode");
                VkDevice device;
                const VkShaderModuleCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_170;
                memcpy((uint64_t*)&cgen_var_170, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_170));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                reservedunmarshal_VkShaderModuleCreateInfo(vkReadStream, (VkShaderModuleCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pShaderModule;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                uint64_t cgen_var_172;
                memcpy((uint64_t*)&cgen_var_172, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkShaderModule*)pShaderModule = (VkShaderModule)(VkShaderModule)((VkShaderModule)(*&cgen_var_172));
                if (pCreateInfo)
                {
                    transform_tohost_VkShaderModuleCreateInfo(m_state, (VkShaderModuleCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateShaderModule 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pShaderModule);
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = vk->vkCreateShaderModule(unboxed_device, pCreateInfo, pAllocator, pShaderModule);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pShaderModule;
                if (vkCreateShaderModule_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_173;
                static_assert(8 == sizeof(VkShaderModule), "handle map overwrite requires VkShaderModule to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkShaderModule((VkShaderModule*)pShaderModule, 1);
                vkStream->write((VkShaderModule*)pShaderModule, 8 * 1);
                // Begin auto non dispatchable handle create for pShaderModule;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateShaderModule_VkResult_return, device, pCreateInfo, pAllocator, pShaderModule);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                android::base::beginTrace("vkDestroyShaderModule decode");
                VkDevice device;
                VkShaderModule shaderModule;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_174;
                memcpy((uint64_t*)&cgen_var_174, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_174));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for shaderModule;
                VkShaderModule boxed_shaderModule_preserve;
                uint64_t cgen_var_175;
                memcpy((uint64_t*)&cgen_var_175, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkShaderModule*)&shaderModule = (VkShaderModule)(VkShaderModule)((VkShaderModule)(*&cgen_var_175));
                boxed_shaderModule_preserve = shaderModule;
                shaderModule = unbox_VkShaderModule(shaderModule);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyShaderModule 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)shaderModule, (unsigned long long)pAllocator);
                }
                vk->vkDestroyShaderModule(unboxed_device, shaderModule, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_shaderModule_preserve, pAllocator);
                }
                delete_VkShaderModule(boxed_shaderModule_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                android::base::beginTrace("vkCreatePipelineCache decode");
                VkDevice device;
                const VkPipelineCacheCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_177;
                memcpy((uint64_t*)&cgen_var_177, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_177));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                reservedunmarshal_VkPipelineCacheCreateInfo(vkReadStream, (VkPipelineCacheCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelineCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                uint64_t cgen_var_179;
                memcpy((uint64_t*)&cgen_var_179, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkPipelineCache*)pPipelineCache = (VkPipelineCache)(VkPipelineCache)((VkPipelineCache)(*&cgen_var_179));
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineCacheCreateInfo(m_state, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreatePipelineCache 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineCache);
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = vk->vkCreatePipelineCache(unboxed_device, pCreateInfo, pAllocator, pPipelineCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineCache;
                if (vkCreatePipelineCache_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_180;
                static_assert(8 == sizeof(VkPipelineCache), "handle map overwrite requires VkPipelineCache to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)pPipelineCache, 1);
                vkStream->write((VkPipelineCache*)pPipelineCache, 8 * 1);
                // Begin auto non dispatchable handle create for pPipelineCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineCache_VkResult_return, device, pCreateInfo, pAllocator, pPipelineCache);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                android::base::beginTrace("vkDestroyPipelineCache decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_181;
                memcpy((uint64_t*)&cgen_var_181, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_181));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineCache;
                VkPipelineCache boxed_pipelineCache_preserve;
                uint64_t cgen_var_182;
                memcpy((uint64_t*)&cgen_var_182, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)(VkPipelineCache)((VkPipelineCache)(*&cgen_var_182));
                boxed_pipelineCache_preserve = pipelineCache;
                pipelineCache = unbox_VkPipelineCache(pipelineCache);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipelineCache 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPipelineCache(unboxed_device, pipelineCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipelineCache_preserve, pAllocator);
                }
                delete_VkPipelineCache(boxed_pipelineCache_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                android::base::beginTrace("vkGetPipelineCacheData decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_184;
                memcpy((uint64_t*)&cgen_var_184, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_184));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_185;
                memcpy((uint64_t*)&cgen_var_185, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_185));
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pDataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDataSize);
                *readStreamPtrPtr += 8;
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    memcpy((size_t*)&(*pDataSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pDataSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, (*(pDataSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPipelineCacheData 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_189 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_189);
                if (pDataSize)
                {
                    uint64_t cgen_var_190 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_190);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_191 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_191);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineCacheData(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineCacheData_VkResult_return, device, pipelineCache, pDataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                android::base::beginTrace("vkMergePipelineCaches decode");
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                const VkPipelineCache* pSrcCaches;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_192;
                memcpy((uint64_t*)&cgen_var_192, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_192));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_193;
                memcpy((uint64_t*)&cgen_var_193, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&dstCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_193));
                memcpy((uint32_t*)&srcCacheCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (((srcCacheCount)))
                {
                    uint8_t* cgen_var_194_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((srcCacheCount));
                    for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_194_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipelineCache*)pSrcCaches) + k) = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMergePipelineCaches 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = vk->vkMergePipelineCaches(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergePipelineCaches(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergePipelineCaches_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                android::base::beginTrace("vkCreateGraphicsPipelines decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkGraphicsPipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_195;
                memcpy((uint64_t*)&cgen_var_195, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_195));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_196;
                memcpy((uint64_t*)&cgen_var_196, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_196));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_198_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_198_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkGraphicsPipelineCreateInfo(m_state, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateGraphicsPipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = vk->vkCreateGraphicsPipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                if (vkCreateGraphicsPipelines_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_199;
                    vkStream->alloc((void**)&cgen_var_199, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requires VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateGraphicsPipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateGraphicsPipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                android::base::beginTrace("vkCreateComputePipelines decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkComputePipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_200;
                memcpy((uint64_t*)&cgen_var_200, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_200));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_201;
                memcpy((uint64_t*)&cgen_var_201, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_201));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkComputePipelineCreateInfo(vkReadStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_203_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_203_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkComputePipelineCreateInfo(m_state, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateComputePipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = vk->vkCreateComputePipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                if (vkCreateComputePipelines_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_204;
                    vkStream->alloc((void**)&cgen_var_204, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requires VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateComputePipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateComputePipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipeline:
            {
                android::base::beginTrace("vkDestroyPipeline decode");
                VkDevice device;
                VkPipeline pipeline;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_205;
                memcpy((uint64_t*)&cgen_var_205, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_205));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipeline;
                VkPipeline boxed_pipeline_preserve;
                uint64_t cgen_var_206;
                memcpy((uint64_t*)&cgen_var_206, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)(VkPipeline)((VkPipeline)(*&cgen_var_206));
                boxed_pipeline_preserve = pipeline;
                pipeline = unbox_VkPipeline(pipeline);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPipeline(unboxed_device, pipeline, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipeline_preserve, pAllocator);
                }
                delete_VkPipeline(boxed_pipeline_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                android::base::beginTrace("vkCreatePipelineLayout decode");
                VkDevice device;
                const VkPipelineLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_208;
                memcpy((uint64_t*)&cgen_var_208, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_208));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                reservedunmarshal_VkPipelineLayoutCreateInfo(vkReadStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelineLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                uint64_t cgen_var_210;
                memcpy((uint64_t*)&cgen_var_210, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkPipelineLayout*)pPipelineLayout = (VkPipelineLayout)(VkPipelineLayout)((VkPipelineLayout)(*&cgen_var_210));
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineLayoutCreateInfo(m_state, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreatePipelineLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineLayout);
                }
                m_state->lock();
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = vk->vkCreatePipelineLayout(unboxed_device, pCreateInfo, pAllocator, pPipelineLayout);
                m_state->unlock();
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineLayout;
                if (vkCreatePipelineLayout_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_211;
                static_assert(8 == sizeof(VkPipelineLayout), "handle map overwrite requires VkPipelineLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)pPipelineLayout, 1);
                vkStream->write((VkPipelineLayout*)pPipelineLayout, 8 * 1);
                // Begin auto non dispatchable handle create for pPipelineLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineLayout_VkResult_return, device, pCreateInfo, pAllocator, pPipelineLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                android::base::beginTrace("vkDestroyPipelineLayout decode");
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_212;
                memcpy((uint64_t*)&cgen_var_212, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_212));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineLayout;
                VkPipelineLayout boxed_pipelineLayout_preserve;
                uint64_t cgen_var_213;
                memcpy((uint64_t*)&cgen_var_213, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&pipelineLayout = (VkPipelineLayout)(VkPipelineLayout)((VkPipelineLayout)(*&cgen_var_213));
                boxed_pipelineLayout_preserve = pipelineLayout;
                pipelineLayout = unbox_VkPipelineLayout(pipelineLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipelineLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineLayout, (unsigned long long)pAllocator);
                }
                std::function<void()> delayed_remove_callback = [vk, unboxed_device, pipelineLayout, pAllocator]() {
                auto state = VkDecoderGlobalState::get();
                state->lock();
                vk->vkDestroyPipelineLayout(unboxed_device, pipelineLayout, pAllocator);
                state->unlock();
                };
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipelineLayout_preserve, pAllocator);
                }
                delayed_delete_VkPipelineLayout(boxed_pipelineLayout_preserve, unboxed_device, delayed_remove_callback);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSampler:
            {
                android::base::beginTrace("vkCreateSampler decode");
                VkDevice device;
                const VkSamplerCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_215;
                memcpy((uint64_t*)&cgen_var_215, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_215));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                reservedunmarshal_VkSamplerCreateInfo(vkReadStream, (VkSamplerCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSampler;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                uint64_t cgen_var_217;
                memcpy((uint64_t*)&cgen_var_217, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSampler*)pSampler = (VkSampler)(VkSampler)((VkSampler)(*&cgen_var_217));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerCreateInfo(m_state, (VkSamplerCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSampler 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSampler);
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_state->on_vkCreateSampler(&m_pool, device, pCreateInfo, pAllocator, pSampler);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_218;
                static_assert(8 == sizeof(VkSampler), "handle map overwrite requires VkSampler to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSampler((VkSampler*)pSampler, 1);
                vkStream->write((VkSampler*)pSampler, 8 * 1);
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSampler_VkResult_return, device, pCreateInfo, pAllocator, pSampler);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySampler:
            {
                android::base::beginTrace("vkDestroySampler decode");
                VkDevice device;
                VkSampler sampler;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_219;
                memcpy((uint64_t*)&cgen_var_219, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_219));
                // Begin manual non dispatchable handle destroy unboxing for sampler;
                VkSampler boxed_sampler_preserve;
                uint64_t cgen_var_220;
                memcpy((uint64_t*)&cgen_var_220, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSampler*)&sampler = (VkSampler)(VkSampler)((VkSampler)(*&cgen_var_220));
                boxed_sampler_preserve = sampler;
                sampler = unbox_VkSampler(sampler);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySampler 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)sampler, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySampler(&m_pool, device, sampler, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_sampler_preserve, pAllocator);
                }
                delete_VkSampler(boxed_sampler_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                android::base::beginTrace("vkCreateDescriptorSetLayout decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_222;
                memcpy((uint64_t*)&cgen_var_222, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_222));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSetLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                uint64_t cgen_var_224;
                memcpy((uint64_t*)&cgen_var_224, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorSetLayout*)pSetLayout = (VkDescriptorSetLayout)(VkDescriptorSetLayout)((VkDescriptorSetLayout)(*&cgen_var_224));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorSetLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSetLayout);
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = m_state->on_vkCreateDescriptorSetLayout(&m_pool, device, pCreateInfo, pAllocator, pSetLayout);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_225;
                static_assert(8 == sizeof(VkDescriptorSetLayout), "handle map overwrite requires VkDescriptorSetLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)pSetLayout, 1);
                vkStream->write((VkDescriptorSetLayout*)pSetLayout, 8 * 1);
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorSetLayout_VkResult_return, device, pCreateInfo, pAllocator, pSetLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                android::base::beginTrace("vkDestroyDescriptorSetLayout decode");
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_226;
                memcpy((uint64_t*)&cgen_var_226, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_226));
                // Begin manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                VkDescriptorSetLayout boxed_descriptorSetLayout_preserve;
                uint64_t cgen_var_227;
                memcpy((uint64_t*)&cgen_var_227, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSetLayout*)&descriptorSetLayout = (VkDescriptorSetLayout)(VkDescriptorSetLayout)((VkDescriptorSetLayout)(*&cgen_var_227));
                boxed_descriptorSetLayout_preserve = descriptorSetLayout;
                descriptorSetLayout = unbox_VkDescriptorSetLayout(descriptorSetLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorSetLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSetLayout, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorSetLayout(&m_pool, device, descriptorSetLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorSetLayout_preserve, pAllocator);
                }
                delete_VkDescriptorSetLayout(boxed_descriptorSetLayout_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                android::base::beginTrace("vkCreateDescriptorPool decode");
                VkDevice device;
                const VkDescriptorPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_229;
                memcpy((uint64_t*)&cgen_var_229, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_229));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                reservedunmarshal_VkDescriptorPoolCreateInfo(vkReadStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                uint64_t cgen_var_231;
                memcpy((uint64_t*)&cgen_var_231, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorPool*)pDescriptorPool = (VkDescriptorPool)(VkDescriptorPool)((VkDescriptorPool)(*&cgen_var_231));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorPoolCreateInfo(m_state, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorPool);
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = m_state->on_vkCreateDescriptorPool(&m_pool, device, pCreateInfo, pAllocator, pDescriptorPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_232;
                static_assert(8 == sizeof(VkDescriptorPool), "handle map overwrite requires VkDescriptorPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)pDescriptorPool, 1);
                vkStream->write((VkDescriptorPool*)pDescriptorPool, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorPool_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                android::base::beginTrace("vkDestroyDescriptorPool decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_233;
                memcpy((uint64_t*)&cgen_var_233, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_233));
                // Begin manual non dispatchable handle destroy unboxing for descriptorPool;
                VkDescriptorPool boxed_descriptorPool_preserve;
                uint64_t cgen_var_234;
                memcpy((uint64_t*)&cgen_var_234, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)(VkDescriptorPool)((VkDescriptorPool)(*&cgen_var_234));
                boxed_descriptorPool_preserve = descriptorPool;
                descriptorPool = unbox_VkDescriptorPool(descriptorPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorPool(&m_pool, device, descriptorPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorPool_preserve, pAllocator);
                }
                delete_VkDescriptorPool(boxed_descriptorPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                android::base::beginTrace("vkResetDescriptorPool decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_236;
                memcpy((uint64_t*)&cgen_var_236, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_236));
                uint64_t cgen_var_237;
                memcpy((uint64_t*)&cgen_var_237, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_237));
                memcpy((VkDescriptorPoolResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkDescriptorPoolResetFlags));
                *readStreamPtrPtr += sizeof(VkDescriptorPoolResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)flags);
                }
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = m_state->on_vkResetDescriptorPool(&m_pool, device, descriptorPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetDescriptorPool_VkResult_return, device, descriptorPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                android::base::beginTrace("vkAllocateDescriptorSets decode");
                VkDevice device;
                const VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_238;
                memcpy((uint64_t*)&cgen_var_238, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_238));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                reservedunmarshal_VkDescriptorSetAllocateInfo(vkReadStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pDescriptorSets;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint8_t* cgen_var_239_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * pAllocateInfo->descriptorSetCount;
                    for (uint32_t k = 0; k < pAllocateInfo->descriptorSetCount; ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_239_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)(VkDescriptorSet)((VkDescriptorSet)tmpval);
                    }
                }
                if (pAllocateInfo)
                {
                    transform_tohost_VkDescriptorSetAllocateInfo(m_state, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateDescriptorSets 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pDescriptorSets);
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = m_state->on_vkAllocateDescriptorSets(&m_pool, device, pAllocateInfo, pDescriptorSets);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_240;
                    vkStream->alloc((void**)&cgen_var_240, pAllocateInfo->descriptorSetCount * 8);
                    static_assert(8 == sizeof(VkDescriptorSet), "handle map overwrite requires VkDescriptorSet to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                    vkStream->write((VkDescriptorSet*)pDescriptorSets, 8 * pAllocateInfo->descriptorSetCount);
                }
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateDescriptorSets_VkResult_return, device, pAllocateInfo, pDescriptorSets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                android::base::beginTrace("vkFreeDescriptorSets decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_241;
                memcpy((uint64_t*)&cgen_var_241, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_241));
                uint64_t cgen_var_242;
                memcpy((uint64_t*)&cgen_var_242, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_242));
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual non dispatchable handle destroy unboxing for pDescriptorSets;
                VkDescriptorSet* boxed_pDescriptorSets_preserve; vkReadStream->alloc((void**)&boxed_pDescriptorSets_preserve, ((descriptorSetCount)) * sizeof(VkDescriptorSet));
                // WARNING PTR CHECK
                memcpy((VkDescriptorSet**)&pDescriptorSets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDescriptorSets);
                *readStreamPtrPtr += 8;
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    if (((descriptorSetCount)))
                    {
                        uint8_t* cgen_var_244_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((descriptorSetCount));
                        for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_244_ptr + k * 8, sizeof(uint64_t));
                            *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)(VkDescriptorSet)((VkDescriptorSet)tmpval);
                        }
                    }
                }
                for (uint32_t i = 0; i < ((descriptorSetCount)); ++i)
                {
                    boxed_pDescriptorSets_preserve[i] = pDescriptorSets[i];
                    ((VkDescriptorSet*)(pDescriptorSets))[i] = unbox_VkDescriptorSet(pDescriptorSets[i]);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets);
                }
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = m_state->on_vkFreeDescriptorSets(&m_pool, device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeDescriptorSets_VkResult_return, device, descriptorPool, descriptorSetCount, boxed_pDescriptorSets_preserve);
                }
                for (uint32_t i = 0; i < ((descriptorSetCount)); ++i)
                {
                    delete_VkDescriptorSet(boxed_pDescriptorSets_preserve[i]);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                android::base::beginTrace("vkUpdateDescriptorSets decode");
                VkDevice device;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                const VkCopyDescriptorSet* pDescriptorCopies;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_245;
                memcpy((uint64_t*)&cgen_var_245, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_245));
                memcpy((uint32_t*)&descriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    reservedunmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&descriptorCopyCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    reservedunmarshal_VkCopyDescriptorSet(vkReadStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i), readStreamPtrPtr);
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (pDescriptorCopies)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                    {
                        transform_tohost_VkCopyDescriptorSet(m_state, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites, (unsigned long long)descriptorCopyCount, (unsigned long long)pDescriptorCopies);
                }
                m_state->on_vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                android::base::beginTrace("vkCreateFramebuffer decode");
                VkDevice device;
                const VkFramebufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_246;
                memcpy((uint64_t*)&cgen_var_246, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_246));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                reservedunmarshal_VkFramebufferCreateInfo(vkReadStream, (VkFramebufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFramebuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                uint64_t cgen_var_248;
                memcpy((uint64_t*)&cgen_var_248, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFramebuffer*)pFramebuffer = (VkFramebuffer)(VkFramebuffer)((VkFramebuffer)(*&cgen_var_248));
                if (pCreateInfo)
                {
                    transform_tohost_VkFramebufferCreateInfo(m_state, (VkFramebufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateFramebuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFramebuffer);
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = vk->vkCreateFramebuffer(unboxed_device, pCreateInfo, pAllocator, pFramebuffer);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFramebuffer;
                if (vkCreateFramebuffer_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_249;
                static_assert(8 == sizeof(VkFramebuffer), "handle map overwrite requires VkFramebuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)pFramebuffer, 1);
                vkStream->write((VkFramebuffer*)pFramebuffer, 8 * 1);
                // Begin auto non dispatchable handle create for pFramebuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFramebuffer_VkResult_return, device, pCreateInfo, pAllocator, pFramebuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                android::base::beginTrace("vkDestroyFramebuffer decode");
                VkDevice device;
                VkFramebuffer framebuffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_250;
                memcpy((uint64_t*)&cgen_var_250, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_250));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for framebuffer;
                VkFramebuffer boxed_framebuffer_preserve;
                uint64_t cgen_var_251;
                memcpy((uint64_t*)&cgen_var_251, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFramebuffer*)&framebuffer = (VkFramebuffer)(VkFramebuffer)((VkFramebuffer)(*&cgen_var_251));
                boxed_framebuffer_preserve = framebuffer;
                framebuffer = unbox_VkFramebuffer(framebuffer);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyFramebuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)framebuffer, (unsigned long long)pAllocator);
                }
                vk->vkDestroyFramebuffer(unboxed_device, framebuffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_framebuffer_preserve, pAllocator);
                }
                delete_VkFramebuffer(boxed_framebuffer_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateRenderPass:
            {
                android::base::beginTrace("vkCreateRenderPass decode");
                VkDevice device;
                const VkRenderPassCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_253;
                memcpy((uint64_t*)&cgen_var_253, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_253));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                reservedunmarshal_VkRenderPassCreateInfo(vkReadStream, (VkRenderPassCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_255;
                memcpy((uint64_t*)&cgen_var_255, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkRenderPass*)pRenderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_255));
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo(m_state, (VkRenderPassCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRenderPass 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = m_state->on_vkCreateRenderPass(&m_pool, device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_256;
                static_assert(8 == sizeof(VkRenderPass), "handle map overwrite requires VkRenderPass to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkRenderPass((VkRenderPass*)pRenderPass, 1);
                vkStream->write((VkRenderPass*)pRenderPass, 8 * 1);
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                android::base::beginTrace("vkDestroyRenderPass decode");
                VkDevice device;
                VkRenderPass renderPass;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_257;
                memcpy((uint64_t*)&cgen_var_257, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_257));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for renderPass;
                VkRenderPass boxed_renderPass_preserve;
                uint64_t cgen_var_258;
                memcpy((uint64_t*)&cgen_var_258, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkRenderPass*)&renderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_258));
                boxed_renderPass_preserve = renderPass;
                renderPass = unbox_VkRenderPass(renderPass);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pAllocator);
                }
                vk->vkDestroyRenderPass(unboxed_device, renderPass, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_renderPass_preserve, pAllocator);
                }
                delete_VkRenderPass(boxed_renderPass_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                android::base::beginTrace("vkGetRenderAreaGranularity decode");
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_260;
                memcpy((uint64_t*)&cgen_var_260, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_260));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_261;
                memcpy((uint64_t*)&cgen_var_261, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkRenderPass*)&renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_261));
                // Begin manual dispatchable handle unboxing for pGranularity;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                reservedunmarshal_VkExtent2D(vkReadStream, (VkExtent2D*)(pGranularity), readStreamPtrPtr);
                if (pGranularity)
                {
                    transform_tohost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRenderAreaGranularity 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pGranularity);
                }
                vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
                vkStream->unsetHandleMapping();
                if (pGranularity)
                {
                    transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRenderAreaGranularity(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, renderPass, pGranularity);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateCommandPool:
            {
                android::base::beginTrace("vkCreateCommandPool decode");
                VkDevice device;
                const VkCommandPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_262;
                memcpy((uint64_t*)&cgen_var_262, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_262));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                reservedunmarshal_VkCommandPoolCreateInfo(vkReadStream, (VkCommandPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pCommandPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                uint64_t cgen_var_264;
                memcpy((uint64_t*)&cgen_var_264, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkCommandPool*)pCommandPool = (VkCommandPool)(VkCommandPool)((VkCommandPool)(*&cgen_var_264));
                if (pCreateInfo)
                {
                    transform_tohost_VkCommandPoolCreateInfo(m_state, (VkCommandPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateCommandPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCommandPool);
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_state->on_vkCreateCommandPool(&m_pool, device, pCreateInfo, pAllocator, pCommandPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_265;
                static_assert(8 == sizeof(VkCommandPool), "handle map overwrite requires VkCommandPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkCommandPool((VkCommandPool*)pCommandPool, 1);
                vkStream->write((VkCommandPool*)pCommandPool, 8 * 1);
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateCommandPool_VkResult_return, device, pCreateInfo, pAllocator, pCommandPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                android::base::beginTrace("vkDestroyCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_266;
                memcpy((uint64_t*)&cgen_var_266, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_266));
                // Begin manual non dispatchable handle destroy unboxing for commandPool;
                VkCommandPool boxed_commandPool_preserve;
                uint64_t cgen_var_267;
                memcpy((uint64_t*)&cgen_var_267, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)(VkCommandPool)((VkCommandPool)(*&cgen_var_267));
                boxed_commandPool_preserve = commandPool;
                commandPool = unbox_VkCommandPool(commandPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_commandPool_preserve, pAllocator);
                }
                delete_VkCommandPool(boxed_commandPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandPool:
            {
                android::base::beginTrace("vkResetCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_269;
                memcpy((uint64_t*)&cgen_var_269, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_269));
                uint64_t cgen_var_270;
                memcpy((uint64_t*)&cgen_var_270, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_270));
                memcpy((VkCommandPoolResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_state->on_vkResetCommandPool(&m_pool, device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandPool_VkResult_return, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                android::base::beginTrace("vkAllocateCommandBuffers decode");
                VkDevice device;
                const VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_271;
                memcpy((uint64_t*)&cgen_var_271, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_271));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                reservedunmarshal_VkCommandBufferAllocateInfo(vkReadStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pCommandBuffers;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (pAllocateInfo->commandBufferCount)
                {
                    uint8_t* cgen_var_272_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * pAllocateInfo->commandBufferCount;
                    for (uint32_t k = 0; k < pAllocateInfo->commandBufferCount; ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_272_ptr + k * 8, sizeof(uint64_t));
                        *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)tmpval);
                    }
                }
                if (pAllocateInfo)
                {
                    transform_tohost_VkCommandBufferAllocateInfo(m_state, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateCommandBuffers 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pCommandBuffers);
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(&m_pool, device, pAllocateInfo, pCommandBuffers);
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_273;
                    vkStream->alloc((void**)&cgen_var_273, pAllocateInfo->commandBufferCount * 8);
                    static_assert(8 == sizeof(VkCommandBuffer), "handle map overwrite requires VkCommandBuffer to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                    vkStream->write((VkCommandBuffer*)pCommandBuffers, 8 * pAllocateInfo->commandBufferCount);
                }
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateCommandBuffers_VkResult_return, device, pAllocateInfo, pCommandBuffers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                android::base::beginTrace("vkFreeCommandBuffers decode");
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_274;
                memcpy((uint64_t*)&cgen_var_274, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_274));
                uint64_t cgen_var_275;
                memcpy((uint64_t*)&cgen_var_275, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_275));
                memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual non dispatchable handle destroy unboxing for pCommandBuffers;
                VkCommandBuffer* boxed_pCommandBuffers_preserve; vkReadStream->alloc((void**)&boxed_pCommandBuffers_preserve, ((commandBufferCount)) * sizeof(VkCommandBuffer));
                // WARNING PTR CHECK
                memcpy((VkCommandBuffer**)&pCommandBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCommandBuffers);
                *readStreamPtrPtr += 8;
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    if (((commandBufferCount)))
                    {
                        uint8_t* cgen_var_277_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((commandBufferCount));
                        for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_277_ptr + k * 8, sizeof(uint64_t));
                            *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)tmpval);
                        }
                    }
                }
                for (uint32_t i = 0; i < ((commandBufferCount)); ++i)
                {
                    boxed_pCommandBuffers_preserve[i] = pCommandBuffers[i];
                    ((VkCommandBuffer*)(pCommandBuffers))[i] = unbox_VkCommandBuffer(pCommandBuffers[i]);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeCommandBuffers 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, commandBufferCount, boxed_pCommandBuffers_preserve);
                }
                for (uint32_t i = 0; i < ((commandBufferCount)); ++i)
                {
                    delete_VkCommandBuffer(boxed_pCommandBuffers_preserve[i]);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                android::base::beginTrace("vkBeginCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_278;
                memcpy((uint64_t*)&cgen_var_278, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_278));
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo), readStreamPtrPtr);
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBeginCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_state->on_vkBeginCommandBuffer(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBeginCommandBuffer_VkResult_return, commandBuffer, pBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                android::base::beginTrace("vkEndCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_279;
                memcpy((uint64_t*)&cgen_var_279, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_279));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEndCommandBuffer 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = vk->vkEndCommandBuffer(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEndCommandBuffer_VkResult_return, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                android::base::beginTrace("vkResetCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_280;
                memcpy((uint64_t*)&cgen_var_280, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_280));
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = m_state->on_vkResetCommandBuffer(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandBuffer_VkResult_return, commandBuffer, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                android::base::beginTrace("vkCmdBindPipeline decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_281;
                memcpy((uint64_t*)&cgen_var_281, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_281));
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_282;
                memcpy((uint64_t*)&cgen_var_282, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_282));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)pipeline);
                }
                m_state->on_vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, pipeline);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetViewport:
            {
                android::base::beginTrace("vkCmdSetViewport decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_283;
                memcpy((uint64_t*)&cgen_var_283, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_283));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkViewport(vkReadStream, (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewport(m_state, (VkViewport*)(pViewports + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewport 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewports);
                }
                vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount, pViewports);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewports);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetScissor:
            {
                android::base::beginTrace("vkCmdSetScissor decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_284;
                memcpy((uint64_t*)&cgen_var_284, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_284));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstScissor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pScissors + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetScissor 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstScissor, (unsigned long long)scissorCount, (unsigned long long)pScissors);
                }
                vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount, pScissors);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetScissor(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstScissor, scissorCount, pScissors);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                android::base::beginTrace("vkCmdSetLineWidth decode");
                VkCommandBuffer commandBuffer;
                float lineWidth;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_285;
                memcpy((uint64_t*)&cgen_var_285, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_285));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&lineWidth, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetLineWidth 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)lineWidth);
                }
                vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetLineWidth(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, lineWidth);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                android::base::beginTrace("vkCmdSetDepthBias decode");
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_286;
                memcpy((uint64_t*)&cgen_var_286, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_286));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&depthBiasConstantFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasClamp, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasSlopeFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthBias 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthBiasConstantFactor, (unsigned long long)depthBiasClamp, (unsigned long long)depthBiasSlopeFactor);
                }
                vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBias(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                android::base::beginTrace("vkCmdSetBlendConstants decode");
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_287;
                memcpy((uint64_t*)&cgen_var_287, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_287));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)blendConstants, *readStreamPtrPtr, 4 * sizeof(const float));
                *readStreamPtrPtr += 4 * sizeof(const float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetBlendConstants 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)blendConstants);
                }
                vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetBlendConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, blendConstants);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                android::base::beginTrace("vkCmdSetDepthBounds decode");
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_288;
                memcpy((uint64_t*)&cgen_var_288, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_288));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&minDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&maxDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthBounds 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)minDepthBounds, (unsigned long long)maxDepthBounds);
                }
                vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBounds(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, minDepthBounds, maxDepthBounds);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                android::base::beginTrace("vkCmdSetStencilCompareMask decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_289;
                memcpy((uint64_t*)&cgen_var_289, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_289));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&compareMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilCompareMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)compareMask);
                }
                vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilCompareMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, compareMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                android::base::beginTrace("vkCmdSetStencilWriteMask decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_290;
                memcpy((uint64_t*)&cgen_var_290, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_290));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&writeMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilWriteMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)writeMask);
                }
                vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilWriteMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, writeMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                android::base::beginTrace("vkCmdSetStencilReference decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_291;
                memcpy((uint64_t*)&cgen_var_291, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_291));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&reference, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilReference 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)reference);
                }
                vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilReference(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, reference);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                android::base::beginTrace("vkCmdBindDescriptorSets decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_292;
                memcpy((uint64_t*)&cgen_var_292, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_292));
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_293;
                memcpy((uint64_t*)&cgen_var_293, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_293));
                memcpy((uint32_t*)&firstSet, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                if (((descriptorSetCount)))
                {
                    uint8_t* cgen_var_294_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((descriptorSetCount));
                    for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_294_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)tmpval);
                    }
                }
                memcpy((uint32_t*)&dynamicOffsetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pDynamicOffsets, *readStreamPtrPtr, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((dynamicOffsetCount)) * sizeof(const uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)firstSet, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets, (unsigned long long)dynamicOffsetCount, (unsigned long long)pDynamicOffsets);
                }
                m_state->on_vkCmdBindDescriptorSets(&m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                android::base::beginTrace("vkCmdBindIndexBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_295;
                memcpy((uint64_t*)&cgen_var_295, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_295));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_296;
                memcpy((uint64_t*)&cgen_var_296, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_296));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                *readStreamPtrPtr += sizeof(VkIndexType);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindIndexBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)indexType);
                }
                vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindIndexBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, indexType);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                android::base::beginTrace("vkCmdBindVertexBuffers decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_297;
                memcpy((uint64_t*)&cgen_var_297, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_297));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint8_t* cgen_var_298_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_298_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindVertexBuffers 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstBinding, (unsigned long long)bindingCount, (unsigned long long)pBuffers, (unsigned long long)pOffsets);
                }
                vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindVertexBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDraw:
            {
                android::base::beginTrace("vkCmdDraw decode");
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_299;
                memcpy((uint64_t*)&cgen_var_299, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_299));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&vertexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstVertex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDraw 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)vertexCount, (unsigned long long)instanceCount, (unsigned long long)firstVertex, (unsigned long long)firstInstance);
                }
                vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDraw(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                android::base::beginTrace("vkCmdDrawIndexed decode");
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_300;
                memcpy((uint64_t*)&cgen_var_300, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_300));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&indexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((int32_t*)&vertexOffset, *readStreamPtrPtr, sizeof(int32_t));
                *readStreamPtrPtr += sizeof(int32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexed 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)indexCount, (unsigned long long)instanceCount, (unsigned long long)firstIndex, (unsigned long long)vertexOffset, (unsigned long long)firstInstance);
                }
                vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexed(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                android::base::beginTrace("vkCmdDrawIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_301;
                memcpy((uint64_t*)&cgen_var_301, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_301));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_302;
                memcpy((uint64_t*)&cgen_var_302, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_302));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_303;
                memcpy((uint64_t*)&cgen_var_303, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_303));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_304;
                memcpy((uint64_t*)&cgen_var_304, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_304));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatch:
            {
                android::base::beginTrace("vkCmdDispatch decode");
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_305;
                memcpy((uint64_t*)&cgen_var_305, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_305));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatch 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatch(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                android::base::beginTrace("vkCmdDispatchIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_306;
                memcpy((uint64_t*)&cgen_var_306, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_306));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_307;
                memcpy((uint64_t*)&cgen_var_307, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_307));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchIndirect 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset);
                }
                vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                android::base::beginTrace("vkCmdCopyBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_308;
                memcpy((uint64_t*)&cgen_var_308, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_308));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_309;
                memcpy((uint64_t*)&cgen_var_309, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_309));
                uint64_t cgen_var_310;
                memcpy((uint64_t*)&cgen_var_310, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_310));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferCopy(vkReadStream, (VkBufferCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferCopy(m_state, (VkBufferCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImage:
            {
                android::base::beginTrace("vkCmdCopyImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_311;
                memcpy((uint64_t*)&cgen_var_311, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_311));
                uint64_t cgen_var_312;
                memcpy((uint64_t*)&cgen_var_312, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_312));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_313;
                memcpy((uint64_t*)&cgen_var_313, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_313));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageCopy(vkReadStream, (VkImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageCopy(m_state, (VkImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBlitImage:
            {
                android::base::beginTrace("vkCmdBlitImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkFilter filter;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_314;
                memcpy((uint64_t*)&cgen_var_314, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_314));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_315;
                memcpy((uint64_t*)&cgen_var_315, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_315));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_316;
                memcpy((uint64_t*)&cgen_var_316, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_316));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageBlit(vkReadStream, (VkImageBlit*)(pRegions + i), readStreamPtrPtr);
                }
                memcpy((VkFilter*)&filter, *readStreamPtrPtr, sizeof(VkFilter));
                *readStreamPtrPtr += sizeof(VkFilter);
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageBlit(m_state, (VkImageBlit*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBlitImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions, (unsigned long long)filter);
                }
                vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBlitImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                android::base::beginTrace("vkCmdCopyBufferToImage decode");
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_317;
                memcpy((uint64_t*)&cgen_var_317, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_317));
                uint64_t cgen_var_318;
                memcpy((uint64_t*)&cgen_var_318, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_318));
                uint64_t cgen_var_319;
                memcpy((uint64_t*)&cgen_var_319, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_319));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBufferToImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBufferToImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                android::base::beginTrace("vkCmdCopyImageToBuffer decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_320;
                memcpy((uint64_t*)&cgen_var_320, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_320));
                uint64_t cgen_var_321;
                memcpy((uint64_t*)&cgen_var_321, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_321));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_322;
                memcpy((uint64_t*)&cgen_var_322, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_322));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImageToBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImageToBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                android::base::beginTrace("vkCmdUpdateBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_323;
                memcpy((uint64_t*)&cgen_var_323, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_323));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_324;
                memcpy((uint64_t*)&cgen_var_324, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_324));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&dataSize, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdUpdateBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdUpdateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                android::base::beginTrace("vkCmdFillBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_325;
                memcpy((uint64_t*)&cgen_var_325, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_325));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_326;
                memcpy((uint64_t*)&cgen_var_326, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_326));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&data, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdFillBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)size, (unsigned long long)data);
                }
                vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdFillBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, size, data);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                android::base::beginTrace("vkCmdClearColorImage decode");
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_327;
                memcpy((uint64_t*)&cgen_var_327, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_327));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_328;
                memcpy((uint64_t*)&cgen_var_328, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_328));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                reservedunmarshal_VkClearColorValue(vkReadStream, (VkClearColorValue*)(pColor), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    reservedunmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pColor)
                {
                    transform_tohost_VkClearColorValue(m_state, (VkClearColorValue*)(pColor));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearColorImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pColor, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearColorImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                android::base::beginTrace("vkCmdClearDepthStencilImage decode");
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_329;
                memcpy((uint64_t*)&cgen_var_329, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_329));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_330;
                memcpy((uint64_t*)&cgen_var_330, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_330));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                reservedunmarshal_VkClearDepthStencilValue(vkReadStream, (VkClearDepthStencilValue*)(pDepthStencil), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    reservedunmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pDepthStencil)
                {
                    transform_tohost_VkClearDepthStencilValue(m_state, (VkClearDepthStencilValue*)(pDepthStencil));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearDepthStencilImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pDepthStencil, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearDepthStencilImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                android::base::beginTrace("vkCmdClearAttachments decode");
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                uint32_t rectCount;
                const VkClearRect* pRects;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_331;
                memcpy((uint64_t*)&cgen_var_331, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_331));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&attachmentCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    reservedunmarshal_VkClearAttachment(vkReadStream, (VkClearAttachment*)(pAttachments + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&rectCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    reservedunmarshal_VkClearRect(vkReadStream, (VkClearRect*)(pRects + i), readStreamPtrPtr);
                }
                if (pAttachments)
                {
                    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                    {
                        transform_tohost_VkClearAttachment(m_state, (VkClearAttachment*)(pAttachments + i));
                    }
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                    {
                        transform_tohost_VkClearRect(m_state, (VkClearRect*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearAttachments 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)attachmentCount, (unsigned long long)pAttachments, (unsigned long long)rectCount, (unsigned long long)pRects);
                }
                vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearAttachments(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResolveImage:
            {
                android::base::beginTrace("vkCmdResolveImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_332;
                memcpy((uint64_t*)&cgen_var_332, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_332));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_333;
                memcpy((uint64_t*)&cgen_var_333, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_333));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_334;
                memcpy((uint64_t*)&cgen_var_334, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_334));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageResolve(vkReadStream, (VkImageResolve*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageResolve(m_state, (VkImageResolve*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResolveImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResolveImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetEvent:
            {
                android::base::beginTrace("vkCmdSetEvent decode");
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_335;
                memcpy((uint64_t*)&cgen_var_335, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_335));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_336;
                memcpy((uint64_t*)&cgen_var_336, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_336));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResetEvent:
            {
                android::base::beginTrace("vkCmdResetEvent decode");
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_337;
                memcpy((uint64_t*)&cgen_var_337, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_337));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_338;
                memcpy((uint64_t*)&cgen_var_338, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_338));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                android::base::beginTrace("vkCmdWaitEvents decode");
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_339;
                memcpy((uint64_t*)&cgen_var_339, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_339));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&eventCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                if (((eventCount)))
                {
                    uint8_t* cgen_var_340_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((eventCount));
                    for (uint32_t k = 0; k < ((eventCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_340_ptr + k * 8, sizeof(uint64_t));
                        *(((VkEvent*)pEvents) + k) = (VkEvent)unbox_VkEvent((VkEvent)tmpval);
                    }
                }
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWaitEvents 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)eventCount, (unsigned long long)pEvents, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWaitEvents(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                android::base::beginTrace("vkCmdPipelineBarrier decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_341;
                memcpy((uint64_t*)&cgen_var_341, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_341));
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkDependencyFlags*)&dependencyFlags, *readStreamPtrPtr, sizeof(VkDependencyFlags));
                *readStreamPtrPtr += sizeof(VkDependencyFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPipelineBarrier 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)dependencyFlags, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                m_state->on_vkCmdPipelineBarrier(&m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPipelineBarrier(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                android::base::beginTrace("vkCmdBeginQuery decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_342;
                memcpy((uint64_t*)&cgen_var_342, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_342));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_343;
                memcpy((uint64_t*)&cgen_var_343, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_343));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryControlFlags));
                *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginQuery 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query, (unsigned long long)flags);
                }
                vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndQuery:
            {
                android::base::beginTrace("vkCmdEndQuery decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_344;
                memcpy((uint64_t*)&cgen_var_344, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_344));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_345;
                memcpy((uint64_t*)&cgen_var_345, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_345));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndQuery 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                android::base::beginTrace("vkCmdResetQueryPool decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_346;
                memcpy((uint64_t*)&cgen_var_346, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_346));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_347;
                memcpy((uint64_t*)&cgen_var_347, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_347));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResetQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount);
                }
                vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                android::base::beginTrace("vkCmdWriteTimestamp decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_348;
                memcpy((uint64_t*)&cgen_var_348, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_348));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineStageFlagBits*)&pipelineStage, *readStreamPtrPtr, sizeof(VkPipelineStageFlagBits));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlagBits);
                uint64_t cgen_var_349;
                memcpy((uint64_t*)&cgen_var_349, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_349));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteTimestamp 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteTimestamp(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, queryPool, query);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                android::base::beginTrace("vkCmdCopyQueryPoolResults decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_350;
                memcpy((uint64_t*)&cgen_var_350, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_350));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_351;
                memcpy((uint64_t*)&cgen_var_351, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_351));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_352;
                memcpy((uint64_t*)&cgen_var_352, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_352));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&stride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                *readStreamPtrPtr += sizeof(VkQueryResultFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)stride, (unsigned long long)flags);
                }
                vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPushConstants:
            {
                android::base::beginTrace("vkCmdPushConstants decode");
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_353;
                memcpy((uint64_t*)&cgen_var_353, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_353));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_354;
                memcpy((uint64_t*)&cgen_var_354, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_354));
                memcpy((VkShaderStageFlags*)&stageFlags, *readStreamPtrPtr, sizeof(VkShaderStageFlags));
                *readStreamPtrPtr += sizeof(VkShaderStageFlags);
                memcpy((uint32_t*)&offset, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&size, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                memcpy((void*)pValues, *readStreamPtrPtr, ((size)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((size)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushConstants 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)layout, (unsigned long long)stageFlags, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)pValues);
                }
                vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size, pValues);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, layout, stageFlags, offset, size, pValues);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                android::base::beginTrace("vkCmdBeginRenderPass decode");
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_355;
                memcpy((uint64_t*)&cgen_var_355, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_355));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin), readStreamPtrPtr);
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)contents);
                }
                vk->vkCmdBeginRenderPass(unboxed_commandBuffer, pRenderPassBegin, contents);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, contents);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                android::base::beginTrace("vkCmdNextSubpass decode");
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_356;
                memcpy((uint64_t*)&cgen_var_356, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_356));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdNextSubpass 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)contents);
                }
                vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, contents);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                android::base::beginTrace("vkCmdEndRenderPass decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_357;
                memcpy((uint64_t*)&cgen_var_357, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_357));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndRenderPass 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndRenderPass(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                android::base::beginTrace("vkCmdExecuteCommands decode");
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_358;
                memcpy((uint64_t*)&cgen_var_358, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_358));
                memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (((commandBufferCount)))
                {
                    uint8_t* cgen_var_359_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((commandBufferCount));
                    for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_359_ptr + k * 8, sizeof(uint64_t));
                        *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdExecuteCommands 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdExecuteCommands(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                android::base::beginTrace("vkEnumerateInstanceVersion decode");
                uint32_t* pApiVersion;
                // Begin manual dispatchable handle unboxing for pApiVersion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                memcpy((uint32_t*)pApiVersion, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceVersion 0x%llx \n", ioStream, (unsigned long long)pApiVersion);
                }
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_state->on_vkEnumerateInstanceVersion(&m_pool, pApiVersion);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceVersion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceVersion_VkResult_return, pApiVersion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                android::base::beginTrace("vkBindBufferMemory2 decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_360;
                memcpy((uint64_t*)&cgen_var_360, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_360));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_state->on_vkBindBufferMemory2(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory2:
            {
                android::base::beginTrace("vkBindImageMemory2 decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_361;
                memcpy((uint64_t*)&cgen_var_361, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_361));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = vk->vkBindImageMemory2(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                android::base::beginTrace("vkGetDeviceGroupPeerMemoryFeatures decode");
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_362;
                memcpy((uint64_t*)&cgen_var_362, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_362));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&heapIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&localDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&remoteDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                memcpy((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, *readStreamPtrPtr, sizeof(VkPeerMemoryFeatureFlags));
                *readStreamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPeerMemoryFeatures 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                android::base::beginTrace("vkCmdSetDeviceMask decode");
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_363;
                memcpy((uint64_t*)&cgen_var_363, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_363));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDeviceMask 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                android::base::beginTrace("vkCmdDispatchBase decode");
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_364;
                memcpy((uint64_t*)&cgen_var_364, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_364));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&baseGroupX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchBase 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBase(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                android::base::beginTrace("vkEnumeratePhysicalDeviceGroups decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_365;
                memcpy((uint64_t*)&cgen_var_365, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_365));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceGroupCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceGroupCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupProperties);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDeviceGroups 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = vk->vkEnumeratePhysicalDeviceGroups(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_368 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_368);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_369 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_369);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroups(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroups_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements2 decode");
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_370;
                memcpy((uint64_t*)&cgen_var_370, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_370));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                reservedunmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements2 decode");
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_371;
                memcpy((uint64_t*)&cgen_var_371, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_371));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                reservedunmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements2 decode");
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_372;
                memcpy((uint64_t*)&cgen_var_372, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_372));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_375 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_375);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_376 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_376);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_377;
                memcpy((uint64_t*)&cgen_var_377, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_377));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                reservedunmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_378;
                memcpy((uint64_t*)&cgen_var_378, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_378));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                reservedunmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_379;
                memcpy((uint64_t*)&cgen_var_379, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_379));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                reservedunmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_380;
                memcpy((uint64_t*)&cgen_var_380, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_380));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                reservedunmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties2 decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_381;
                memcpy((uint64_t*)&cgen_var_381, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_381));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties2**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_384 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_384);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_385 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_385);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_386;
                memcpy((uint64_t*)&cgen_var_386, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_386));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_387;
                memcpy((uint64_t*)&cgen_var_387, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_387));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties2**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_390 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_390);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_391 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_391);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkTrimCommandPool:
            {
                android::base::beginTrace("vkTrimCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_392;
                memcpy((uint64_t*)&cgen_var_392, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_392));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_393;
                memcpy((uint64_t*)&cgen_var_393, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_393));
                memcpy((VkCommandPoolTrimFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolTrimFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolTrimFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkTrimCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                android::base::beginTrace("vkGetDeviceQueue2 decode");
                VkDevice device;
                const VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_394;
                memcpy((uint64_t*)&cgen_var_394, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_394));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                reservedunmarshal_VkDeviceQueueInfo2(vkReadStream, (VkDeviceQueueInfo2*)(pQueueInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_395;
                memcpy((uint64_t*)&cgen_var_395, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueue*)pQueue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_395));
                if (pQueueInfo)
                {
                    transform_tohost_VkDeviceQueueInfo2(m_state, (VkDeviceQueueInfo2*)(pQueueInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceQueue2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pQueueInfo, (unsigned long long)pQueue);
                }
                vk->vkGetDeviceQueue2(unboxed_device, pQueueInfo, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_396;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_396, 1);
                vkStream->write((uint64_t*)&cgen_var_396, 8);
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pQueueInfo, pQueue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                android::base::beginTrace("vkCreateSamplerYcbcrConversion decode");
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_397;
                memcpy((uint64_t*)&cgen_var_397, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_397));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_399;
                memcpy((uint64_t*)&cgen_var_399, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSamplerYcbcrConversion*)pYcbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_399));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSamplerYcbcrConversion 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = vk->vkCreateSamplerYcbcrConversion(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversion_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_400;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requires VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversion_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                android::base::beginTrace("vkDestroySamplerYcbcrConversion decode");
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_401;
                memcpy((uint64_t*)&cgen_var_401, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_401));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                uint64_t cgen_var_402;
                memcpy((uint64_t*)&cgen_var_402, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSamplerYcbcrConversion*)&ycbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_402));
                boxed_ycbcrConversion_preserve = ycbcrConversion;
                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySamplerYcbcrConversion 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversion(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_ycbcrConversion_preserve, pAllocator);
                }
                delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                android::base::beginTrace("vkCreateDescriptorUpdateTemplate decode");
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_404;
                memcpy((uint64_t*)&cgen_var_404, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_404));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_406;
                memcpy((uint64_t*)&cgen_var_406, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_406));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplate(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_407;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requires VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                android::base::beginTrace("vkDestroyDescriptorUpdateTemplate decode");
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_408;
                memcpy((uint64_t*)&cgen_var_408, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_408));
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
                uint64_t cgen_var_409;
                memcpy((uint64_t*)&cgen_var_409, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_409));
                boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                descriptorUpdateTemplate = unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplate(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplate decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_411;
                memcpy((uint64_t*)&cgen_var_411, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_411));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_412;
                memcpy((uint64_t*)&cgen_var_412, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_412));
                uint64_t cgen_var_413;
                memcpy((uint64_t*)&cgen_var_413, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_413));
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalBufferProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_415;
                memcpy((uint64_t*)&cgen_var_415, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_415));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                reservedunmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties), readStreamPtrPtr);
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalBufferProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferProperties(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalFenceProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_416;
                memcpy((uint64_t*)&cgen_var_416, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_416));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                reservedunmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties), readStreamPtrPtr);
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalFenceProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFenceProperties(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFenceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalSemaphoreProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_417;
                memcpy((uint64_t*)&cgen_var_417, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_417));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                reservedunmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), readStreamPtrPtr);
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalSemaphoreProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphoreProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                android::base::beginTrace("vkGetDescriptorSetLayoutSupport decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_418;
                memcpy((uint64_t*)&cgen_var_418, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_418));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                reservedunmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDescriptorSetLayoutSupport 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                android::base::beginTrace("vkDestroySurfaceKHR decode");
                VkInstance instance;
                VkSurfaceKHR surface;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_419;
                memcpy((uint64_t*)&cgen_var_419, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_419));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for surface;
                VkSurfaceKHR boxed_surface_preserve;
                uint64_t cgen_var_420;
                memcpy((uint64_t*)&cgen_var_420, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_420));
                boxed_surface_preserve = surface;
                surface = unbox_VkSurfaceKHR(surface);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySurfaceKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)surface, (unsigned long long)pAllocator);
                }
                vk->vkDestroySurfaceKHR(unboxed_instance, surface, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_surface_preserve, pAllocator);
                }
                delete_VkSurfaceKHR(boxed_surface_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_422;
                memcpy((uint64_t*)&cgen_var_422, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_422));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_423;
                memcpy((uint64_t*)&cgen_var_423, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_423));
                // Begin manual dispatchable handle unboxing for pSupported;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                memcpy((VkBool32*)pSupported, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)surface, (unsigned long long)pSupported);
                }
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceSupportKHR(unboxed_physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->unsetHandleMapping();
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, physicalDevice, queueFamilyIndex, surface, pSupported);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilitiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_424;
                memcpy((uint64_t*)&cgen_var_424, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_424));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_425;
                memcpy((uint64_t*)&cgen_var_425, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_425));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                reservedunmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilitiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceFormatsKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_426;
                memcpy((uint64_t*)&cgen_var_426, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_426));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_427;
                memcpy((uint64_t*)&cgen_var_427, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_427));
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSurfaceFormatCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormatCount);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSurfaceFormatCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSurfaceFormatKHR**)&pSurfaceFormats, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormats);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        reservedunmarshal_VkSurfaceFormatKHR(vkReadStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), readStreamPtrPtr);
                    }
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceFormatsKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormatsKHR(unboxed_physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_430 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_430);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_431 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_431);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormatsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfacePresentModesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_432;
                memcpy((uint64_t*)&cgen_var_432, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_432));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_433;
                memcpy((uint64_t*)&cgen_var_433, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_433));
                // Begin manual dispatchable handle unboxing for pPresentModeCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPresentModeCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModeCount);
                *readStreamPtrPtr += 8;
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPresentModeCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPresentModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPresentModeKHR**)&pPresentModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModes);
                *readStreamPtrPtr += 8;
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    memcpy((VkPresentModeKHR*)pPresentModes, *readStreamPtrPtr, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    *readStreamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pPresentModeCount, (unsigned long long)pPresentModes);
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfacePresentModesKHR(unboxed_physicalDevice, surface, pPresentModeCount, pPresentModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_436 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_436);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_437 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_437);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, physicalDevice, surface, pPresentModeCount, pPresentModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                android::base::beginTrace("vkCreateSwapchainKHR decode");
                VkDevice device;
                const VkSwapchainCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_438;
                memcpy((uint64_t*)&cgen_var_438, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_438));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                reservedunmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSwapchain;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                uint64_t cgen_var_440;
                memcpy((uint64_t*)&cgen_var_440, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSwapchainKHR*)pSwapchain = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)(*&cgen_var_440));
                if (pCreateInfo)
                {
                    transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSwapchainKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSwapchain);
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = vk->vkCreateSwapchainKHR(unboxed_device, pCreateInfo, pAllocator, pSwapchain);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pSwapchain;
                if (vkCreateSwapchainKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_441;
                static_assert(8 == sizeof(VkSwapchainKHR), "handle map overwrite requires VkSwapchainKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)pSwapchain, 1);
                vkStream->write((VkSwapchainKHR*)pSwapchain, 8 * 1);
                // Begin auto non dispatchable handle create for pSwapchain;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSwapchainKHR_VkResult_return, device, pCreateInfo, pAllocator, pSwapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                android::base::beginTrace("vkDestroySwapchainKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_442;
                memcpy((uint64_t*)&cgen_var_442, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_442));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for swapchain;
                VkSwapchainKHR boxed_swapchain_preserve;
                uint64_t cgen_var_443;
                memcpy((uint64_t*)&cgen_var_443, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)(*&cgen_var_443));
                boxed_swapchain_preserve = swapchain;
                swapchain = unbox_VkSwapchainKHR(swapchain);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySwapchainKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pAllocator);
                }
                vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_swapchain_preserve, pAllocator);
                }
                delete_VkSwapchainKHR(boxed_swapchain_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                android::base::beginTrace("vkGetSwapchainImagesKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_445;
                memcpy((uint64_t*)&cgen_var_445, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_445));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_446;
                memcpy((uint64_t*)&cgen_var_446, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_446));
                // Begin manual dispatchable handle unboxing for pSwapchainImageCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSwapchainImageCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSwapchainImageCount);
                *readStreamPtrPtr += 8;
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSwapchainImageCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSwapchainImages;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkImage**)&pSwapchainImages, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSwapchainImages);
                *readStreamPtrPtr += 8;
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    if ((*(pSwapchainImageCount)))
                    {
                        uint8_t* cgen_var_449_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pSwapchainImageCount));
                        for (uint32_t k = 0; k < (*(pSwapchainImageCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_449_ptr + k * 8, sizeof(uint64_t));
                            *(((VkImage*)pSwapchainImages) + k) = (VkImage)(VkImage)((VkImage)tmpval);
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainImagesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pSwapchainImageCount, (unsigned long long)pSwapchainImages);
                }
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_450 = (uint64_t)(uintptr_t)pSwapchainImageCount;
                vkStream->putBe64(cgen_var_450);
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_451 = (uint64_t)(uintptr_t)pSwapchainImages;
                vkStream->putBe64(cgen_var_451);
                if (pSwapchainImages)
                {
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_452;
                        vkStream->alloc((void**)&cgen_var_452, (*(pSwapchainImageCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_452, (*(pSwapchainImageCount)));
                        vkStream->write((uint64_t*)cgen_var_452, (*(pSwapchainImageCount)) * 8);
                    }
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainImagesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainImagesKHR_VkResult_return, device, swapchain, pSwapchainImageCount, pSwapchainImages);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                android::base::beginTrace("vkAcquireNextImageKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_453;
                memcpy((uint64_t*)&cgen_var_453, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_453));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_454;
                memcpy((uint64_t*)&cgen_var_454, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_454));
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                uint64_t cgen_var_455;
                memcpy((uint64_t*)&cgen_var_455, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_455));
                uint64_t cgen_var_456;
                memcpy((uint64_t*)&cgen_var_456, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_456));
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                memcpy((uint32_t*)pImageIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireNextImageKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)timeout, (unsigned long long)semaphore, (unsigned long long)fence, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImageKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImageKHR_VkResult_return, device, swapchain, timeout, semaphore, fence, pImageIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                android::base::beginTrace("vkQueuePresentKHR decode");
                VkQueue queue;
                const VkPresentInfoKHR* pPresentInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_457;
                memcpy((uint64_t*)&cgen_var_457, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_457));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                reservedunmarshal_VkPresentInfoKHR(vkReadStream, (VkPresentInfoKHR*)(pPresentInfo), readStreamPtrPtr);
                if (pPresentInfo)
                {
                    transform_tohost_VkPresentInfoKHR(m_state, (VkPresentInfoKHR*)(pPresentInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueuePresentKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pPresentInfo);
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = vk->vkQueuePresentKHR(unboxed_queue, pPresentInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueuePresentKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueuePresentKHR_VkResult_return, queue, pPresentInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupPresentCapabilitiesKHR decode");
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_458;
                memcpy((uint64_t*)&cgen_var_458, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_458));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                reservedunmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), readStreamPtrPtr);
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_tohost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPresentCapabilitiesKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceGroupPresentCapabilities);
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device, pDeviceGroupPresentCapabilities);
                vkStream->unsetHandleMapping();
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPresentCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, device, pDeviceGroupPresentCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupSurfacePresentModesKHR decode");
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_459;
                memcpy((uint64_t*)&cgen_var_459, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_459));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_460;
                memcpy((uint64_t*)&cgen_var_460, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_460));
                // Begin manual dispatchable handle unboxing for pModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDeviceGroupPresentModeFlagsKHR**)&pModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pModes);
                *readStreamPtrPtr += 8;
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    memcpy((VkDeviceGroupPresentModeFlagsKHR*)pModes, *readStreamPtrPtr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    *readStreamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)surface, (unsigned long long)pModes);
                }
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_462 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_462);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, device, surface, pModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDevicePresentRectanglesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_463;
                memcpy((uint64_t*)&cgen_var_463, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_463));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_464;
                memcpy((uint64_t*)&cgen_var_464, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_464));
                // Begin manual dispatchable handle unboxing for pRectCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pRectCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pRectCount);
                *readStreamPtrPtr += 8;
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pRectCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pRects;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkRect2D**)&pRects, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pRects);
                *readStreamPtrPtr += 8;
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        reservedunmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pRects + i), readStreamPtrPtr);
                    }
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDevicePresentRectanglesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pRectCount, (unsigned long long)pRects);
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface, pRectCount, pRects);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_467 = (uint64_t)(uintptr_t)pRectCount;
                vkStream->putBe64(cgen_var_467);
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_fromhost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_468 = (uint64_t)(uintptr_t)pRects;
                vkStream->putBe64(cgen_var_468);
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDevicePresentRectanglesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, physicalDevice, surface, pRectCount, pRects);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                android::base::beginTrace("vkAcquireNextImage2KHR decode");
                VkDevice device;
                const VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_469;
                memcpy((uint64_t*)&cgen_var_469, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_469));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                reservedunmarshal_VkAcquireNextImageInfoKHR(vkReadStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                memcpy((uint32_t*)pImageIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (pAcquireInfo)
                {
                    transform_tohost_VkAcquireNextImageInfoKHR(m_state, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireNextImage2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAcquireInfo, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImage2KHR_VkResult_return, device, pAcquireInfo, pImageIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_470;
                memcpy((uint64_t*)&cgen_var_470, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_470));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPropertiesKHR(vkReadStream, (VkDisplayPropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_473 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_473);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_474 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_474);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPlanePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_475;
                memcpy((uint64_t*)&cgen_var_475, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_475));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPlanePropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPlanePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_478 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_478);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_479 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_479);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneSupportedDisplaysKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_480;
                memcpy((uint64_t*)&cgen_var_480, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_480));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&planeIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pDisplayCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pDisplayCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDisplayCount);
                *readStreamPtrPtr += 8;
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pDisplayCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pDisplays;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayKHR**)&pDisplays, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDisplays);
                *readStreamPtrPtr += 8;
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    if ((*(pDisplayCount)))
                    {
                        uint8_t* cgen_var_483_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pDisplayCount));
                        for (uint32_t k = 0; k < (*(pDisplayCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_483_ptr + k * 8, sizeof(uint64_t));
                            *(((VkDisplayKHR*)pDisplays) + k) = (VkDisplayKHR)(VkDisplayKHR)((VkDisplayKHR)tmpval);
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneSupportedDisplaysKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)planeIndex, (unsigned long long)pDisplayCount, (unsigned long long)pDisplays);
                }
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = vk->vkGetDisplayPlaneSupportedDisplaysKHR(unboxed_physicalDevice, planeIndex, pDisplayCount, pDisplays);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_484 = (uint64_t)(uintptr_t)pDisplayCount;
                vkStream->putBe64(cgen_var_484);
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_485 = (uint64_t)(uintptr_t)pDisplays;
                vkStream->putBe64(cgen_var_485);
                if (pDisplays)
                {
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_486;
                        vkStream->alloc((void**)&cgen_var_486, (*(pDisplayCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_486, (*(pDisplayCount)));
                        vkStream->write((uint64_t*)cgen_var_486, (*(pDisplayCount)) * 8);
                    }
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneSupportedDisplaysKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, physicalDevice, planeIndex, pDisplayCount, pDisplays);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                android::base::beginTrace("vkGetDisplayModePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_487;
                memcpy((uint64_t*)&cgen_var_487, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_487));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_488;
                memcpy((uint64_t*)&cgen_var_488, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_488));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayModePropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayModePropertiesKHR(vkReadStream, (VkDisplayModePropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayModePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = vk->vkGetDisplayModePropertiesKHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_491 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_491);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_492 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_492);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModePropertiesKHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                android::base::beginTrace("vkCreateDisplayModeKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                const VkDisplayModeCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_493;
                memcpy((uint64_t*)&cgen_var_493, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_493));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_494;
                memcpy((uint64_t*)&cgen_var_494, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_494));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                reservedunmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMode;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                uint64_t cgen_var_496;
                memcpy((uint64_t*)&cgen_var_496, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDisplayModeKHR*)pMode = (VkDisplayModeKHR)(VkDisplayModeKHR)((VkDisplayModeKHR)(*&cgen_var_496));
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplayModeCreateInfoKHR(m_state, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDisplayModeKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMode);
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = vk->vkCreateDisplayModeKHR(unboxed_physicalDevice, display, pCreateInfo, pAllocator, pMode);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMode;
                if (vkCreateDisplayModeKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_497;
                static_assert(8 == sizeof(VkDisplayModeKHR), "handle map overwrite requires VkDisplayModeKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)pMode, 1);
                vkStream->write((VkDisplayModeKHR*)pMode, 8 * 1);
                // Begin auto non dispatchable handle create for pMode;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayModeKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayModeKHR_VkResult_return, physicalDevice, display, pCreateInfo, pAllocator, pMode);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneCapabilitiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_498;
                memcpy((uint64_t*)&cgen_var_498, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_498));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_499;
                memcpy((uint64_t*)&cgen_var_499, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayModeKHR*)&mode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_499));
                memcpy((uint32_t*)&planeIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), readStreamPtrPtr);
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneCapabilitiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)mode, (unsigned long long)planeIndex, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = vk->vkGetDisplayPlaneCapabilitiesKHR(unboxed_physicalDevice, mode, planeIndex, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, physicalDevice, mode, planeIndex, pCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                android::base::beginTrace("vkCreateDisplayPlaneSurfaceKHR decode");
                VkInstance instance;
                const VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_500;
                memcpy((uint64_t*)&cgen_var_500, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_500));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                reservedunmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_502;
                memcpy((uint64_t*)&cgen_var_502, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_502));
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplaySurfaceCreateInfoKHR(m_state, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDisplayPlaneSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = vk->vkCreateDisplayPlaneSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_503;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_503, 1);
                vkStream->write((uint64_t*)&cgen_var_503, 8);
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayPlaneSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayPlaneSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                android::base::beginTrace("vkCreateSharedSwapchainsKHR decode");
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_504;
                memcpy((uint64_t*)&cgen_var_504, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_504));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&swapchainCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    reservedunmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSwapchains;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint8_t* cgen_var_506_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((swapchainCount));
                    for (uint32_t k = 0; k < ((swapchainCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_506_ptr + k * 8, sizeof(uint64_t));
                        *(((VkSwapchainKHR*)pSwapchains) + k) = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSharedSwapchainsKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pSwapchains);
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = vk->vkCreateSharedSwapchainsKHR(unboxed_device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                vkStream->unsetHandleMapping();
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_507;
                    vkStream->alloc((void**)&cgen_var_507, ((swapchainCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_507, ((swapchainCount)));
                    vkStream->write((uint64_t*)cgen_var_507, ((swapchainCount)) * 8);
                }
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSharedSwapchainsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSharedSwapchainsKHR_VkResult_return, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                android::base::beginTrace("vkCreateXlibSurfaceKHR decode");
                VkInstance instance;
                const VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_508;
                memcpy((uint64_t*)&cgen_var_508, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_508));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                reservedunmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_510;
                memcpy((uint64_t*)&cgen_var_510, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_510));
                if (pCreateInfo)
                {
                    transform_tohost_VkXlibSurfaceCreateInfoKHR(m_state, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateXlibSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = vk->vkCreateXlibSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_511;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_511, 1);
                vkStream->write((uint64_t*)&cgen_var_511, 8);
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateXlibSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateXlibSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceXlibPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_512;
                memcpy((uint64_t*)&cgen_var_512, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_512));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                memcpy((VisualID*)&visualID, *readStreamPtrPtr, sizeof(VisualID));
                *readStreamPtrPtr += sizeof(VisualID);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceXlibPresentationSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)dpy, (unsigned long long)visualID);
                }
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceXlibPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, dpy, visualID);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                android::base::beginTrace("vkCreateXcbSurfaceKHR decode");
                VkInstance instance;
                const VkXcbSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_513;
                memcpy((uint64_t*)&cgen_var_513, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_513));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
                reservedunmarshal_VkXcbSurfaceCreateInfoKHR(vkReadStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_515;
                memcpy((uint64_t*)&cgen_var_515, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_515));
                if (pCreateInfo)
                {
                    transform_tohost_VkXcbSurfaceCreateInfoKHR(m_state, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateXcbSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXcbSurfaceKHR_VkResult_return = vk->vkCreateXcbSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_516;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_516, 1);
                vkStream->write((uint64_t*)&cgen_var_516, 8);
                vkStream->write(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateXcbSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateXcbSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceXcbPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                xcb_connection_t* connection;
                xcb_visualid_t visual_id;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_517;
                memcpy((uint64_t*)&cgen_var_517, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_517));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(xcb_connection_t));
                memcpy((xcb_connection_t*)connection, *readStreamPtrPtr, sizeof(xcb_connection_t));
                *readStreamPtrPtr += sizeof(xcb_connection_t);
                memcpy((xcb_visualid_t*)&visual_id, *readStreamPtrPtr, sizeof(xcb_visualid_t));
                *readStreamPtrPtr += sizeof(xcb_visualid_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceXcbPresentationSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)connection, (unsigned long long)visual_id);
                }
                VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXcbPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection, visual_id);
                vkStream->unsetHandleMapping();
                vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkStream->write(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceXcbPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection, visual_id);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                android::base::beginTrace("vkCreateWaylandSurfaceKHR decode");
                VkInstance instance;
                const VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_518;
                memcpy((uint64_t*)&cgen_var_518, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_518));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                reservedunmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_520;
                memcpy((uint64_t*)&cgen_var_520, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_520));
                if (pCreateInfo)
                {
                    transform_tohost_VkWaylandSurfaceCreateInfoKHR(m_state, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateWaylandSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = vk->vkCreateWaylandSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_521;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_521, 1);
                vkStream->write((uint64_t*)&cgen_var_521, 8);
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWaylandSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWaylandSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceWaylandPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_522;
                memcpy((uint64_t*)&cgen_var_522, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_522));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for display;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                memcpy((wl_display*)display, *readStreamPtrPtr, sizeof(wl_display));
                *readStreamPtrPtr += sizeof(wl_display);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceWaylandPresentationSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)display);
                }
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, display);
                vkStream->unsetHandleMapping();
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWaylandPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_mir_surface
            case OP_vkCreateMirSurfaceKHR:
            {
                android::base::beginTrace("vkCreateMirSurfaceKHR decode");
                VkInstance instance;
                const VkMirSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_523;
                memcpy((uint64_t*)&cgen_var_523, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_523));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
                reservedunmarshal_VkMirSurfaceCreateInfoKHR(vkReadStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_525;
                memcpy((uint64_t*)&cgen_var_525, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_525));
                if (pCreateInfo)
                {
                    transform_tohost_VkMirSurfaceCreateInfoKHR(m_state, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateMirSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateMirSurfaceKHR_VkResult_return = vk->vkCreateMirSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_526;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_526, 1);
                vkStream->write((uint64_t*)&cgen_var_526, 8);
                vkStream->write(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateMirSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateMirSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMirPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMirPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                MirConnection* connection;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_527;
                memcpy((uint64_t*)&cgen_var_527, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_527));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(MirConnection));
                memcpy((MirConnection*)connection, *readStreamPtrPtr, sizeof(MirConnection));
                *readStreamPtrPtr += sizeof(MirConnection);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMirPresentationSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)connection);
                }
                VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceMirPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection);
                vkStream->unsetHandleMapping();
                vkStream->write((MirConnection*)connection, sizeof(MirConnection));
                vkStream->write(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMirPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                android::base::beginTrace("vkCreateAndroidSurfaceKHR decode");
                VkInstance instance;
                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_528;
                memcpy((uint64_t*)&cgen_var_528, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_528));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                reservedunmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_530;
                memcpy((uint64_t*)&cgen_var_530, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_530));
                if (pCreateInfo)
                {
                    transform_tohost_VkAndroidSurfaceCreateInfoKHR(m_state, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateAndroidSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = vk->vkCreateAndroidSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_531;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_531, 1);
                vkStream->write((uint64_t*)&cgen_var_531, 8);
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateAndroidSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateAndroidSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                android::base::beginTrace("vkCreateWin32SurfaceKHR decode");
                VkInstance instance;
                const VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_532;
                memcpy((uint64_t*)&cgen_var_532, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_532));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                reservedunmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_534;
                memcpy((uint64_t*)&cgen_var_534, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_534));
                if (pCreateInfo)
                {
                    transform_tohost_VkWin32SurfaceCreateInfoKHR(m_state, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateWin32SurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = vk->vkCreateWin32SurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_535;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_535, 1);
                vkStream->write((uint64_t*)&cgen_var_535, 8);
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWin32SurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWin32SurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceWin32PresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_536;
                memcpy((uint64_t*)&cgen_var_536, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_536));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceWin32PresentationSupportKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex);
                }
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWin32PresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_537;
                memcpy((uint64_t*)&cgen_var_537, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_537));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                reservedunmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_538;
                memcpy((uint64_t*)&cgen_var_538, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_538));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                reservedunmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_539;
                memcpy((uint64_t*)&cgen_var_539, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_539));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                reservedunmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_540;
                memcpy((uint64_t*)&cgen_var_540, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_540));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                reservedunmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_541;
                memcpy((uint64_t*)&cgen_var_541, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_541));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties2**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_544 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_544);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_545 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_545);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_546;
                memcpy((uint64_t*)&cgen_var_546, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_546));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_547;
                memcpy((uint64_t*)&cgen_var_547, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_547));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties2**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_550 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_550);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_551 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_551);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupPeerMemoryFeaturesKHR decode");
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_552;
                memcpy((uint64_t*)&cgen_var_552, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_552));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&heapIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&localDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&remoteDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                memcpy((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, *readStreamPtrPtr, sizeof(VkPeerMemoryFeatureFlags));
                *readStreamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPeerMemoryFeaturesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeaturesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                android::base::beginTrace("vkCmdSetDeviceMaskKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_553;
                memcpy((uint64_t*)&cgen_var_553, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_553));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDeviceMaskKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMaskKHR(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMaskKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                android::base::beginTrace("vkCmdDispatchBaseKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_554;
                memcpy((uint64_t*)&cgen_var_554, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_554));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&baseGroupX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchBaseKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBaseKHR(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBaseKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                android::base::beginTrace("vkTrimCommandPoolKHR decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_555;
                memcpy((uint64_t*)&cgen_var_555, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_555));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_556;
                memcpy((uint64_t*)&cgen_var_556, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_556));
                memcpy((VkCommandPoolTrimFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolTrimFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolTrimFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkTrimCommandPoolKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPoolKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                android::base::beginTrace("vkEnumeratePhysicalDeviceGroupsKHR decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_557;
                memcpy((uint64_t*)&cgen_var_557, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_557));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceGroupCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceGroupCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupProperties);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDeviceGroupsKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = vk->vkEnumeratePhysicalDeviceGroupsKHR(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_560 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_560);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_561 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_561);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroupsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalBufferPropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_562;
                memcpy((uint64_t*)&cgen_var_562, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_562));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                reservedunmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties), readStreamPtrPtr);
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalBufferPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                android::base::beginTrace("vkGetMemoryWin32HandleKHR decode");
                VkDevice device;
                const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_563;
                memcpy((uint64_t*)&cgen_var_563, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_563));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                reservedunmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkMemoryGetWin32HandleInfoKHR(m_state, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = vk->vkGetMemoryWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                android::base::beginTrace("vkGetMemoryWin32HandlePropertiesKHR decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_564;
                memcpy((uint64_t*)&cgen_var_564, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_564));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                memcpy((HANDLE*)&handle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                // Begin manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                reservedunmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), readStreamPtrPtr);
                if (pMemoryWin32HandleProperties)
                {
                    transform_tohost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandlePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)handle, (unsigned long long)pMemoryWin32HandleProperties);
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vk->vkGetMemoryWin32HandlePropertiesKHR(unboxed_device, handleType, handle, pMemoryWin32HandleProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryWin32HandleProperties)
                {
                    transform_fromhost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandlePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, device, handleType, handle, pMemoryWin32HandleProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                android::base::beginTrace("vkGetMemoryFdKHR decode");
                VkDevice device;
                const VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_565;
                memcpy((uint64_t*)&cgen_var_565, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_565));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                reservedunmarshal_VkMemoryGetFdInfoKHR(vkReadStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkMemoryGetFdInfoKHR(m_state, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = vk->vkGetMemoryFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                android::base::beginTrace("vkGetMemoryFdPropertiesKHR decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_566;
                memcpy((uint64_t*)&cgen_var_566, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_566));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                memcpy((int*)&fd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                // Begin manual dispatchable handle unboxing for pMemoryFdProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                reservedunmarshal_VkMemoryFdPropertiesKHR(vkReadStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), readStreamPtrPtr);
                if (pMemoryFdProperties)
                {
                    transform_tohost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryFdPropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)fd, (unsigned long long)pMemoryFdProperties);
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = vk->vkGetMemoryFdPropertiesKHR(unboxed_device, handleType, fd, pMemoryFdProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryFdProperties)
                {
                    transform_fromhost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdPropertiesKHR_VkResult_return, device, handleType, fd, pMemoryFdProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_567;
                memcpy((uint64_t*)&cgen_var_567, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_567));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                reservedunmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), readStreamPtrPtr);
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                android::base::beginTrace("vkImportSemaphoreWin32HandleKHR decode");
                VkDevice device;
                const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_568;
                memcpy((uint64_t*)&cgen_var_568, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_568));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                reservedunmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo), readStreamPtrPtr);
                if (pImportSemaphoreWin32HandleInfo)
                {
                    transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(m_state, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportSemaphoreWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreWin32HandleInfo);
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = vk->vkImportSemaphoreWin32HandleKHR(unboxed_device, pImportSemaphoreWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreWin32HandleKHR_VkResult_return, device, pImportSemaphoreWin32HandleInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                android::base::beginTrace("vkGetSemaphoreWin32HandleKHR decode");
                VkDevice device;
                const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_569;
                memcpy((uint64_t*)&cgen_var_569, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_569));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                reservedunmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(m_state, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = vk->vkGetSemaphoreWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                android::base::beginTrace("vkImportSemaphoreFdKHR decode");
                VkDevice device;
                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_570;
                memcpy((uint64_t*)&cgen_var_570, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_570));
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                reservedunmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo), readStreamPtrPtr);
                if (pImportSemaphoreFdInfo)
                {
                    transform_tohost_VkImportSemaphoreFdInfoKHR(m_state, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportSemaphoreFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreFdInfo);
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_state->on_vkImportSemaphoreFdKHR(&m_pool, device, pImportSemaphoreFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreFdKHR_VkResult_return, device, pImportSemaphoreFdInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                android::base::beginTrace("vkGetSemaphoreFdKHR decode");
                VkDevice device;
                const VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_571;
                memcpy((uint64_t*)&cgen_var_571, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_571));
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                reservedunmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkSemaphoreGetFdInfoKHR(m_state, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_state->on_vkGetSemaphoreFdKHR(&m_pool, device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                android::base::beginTrace("vkCmdPushDescriptorSetKHR decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_572;
                memcpy((uint64_t*)&cgen_var_572, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_572));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_573;
                memcpy((uint64_t*)&cgen_var_573, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_573));
                memcpy((uint32_t*)&set, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&descriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    reservedunmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i), readStreamPtrPtr);
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushDescriptorSetKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites);
                }
                vk->vkCmdPushDescriptorSetKHR(unboxed_commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                android::base::beginTrace("vkCmdPushDescriptorSetWithTemplateKHR decode");
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_574;
                memcpy((uint64_t*)&cgen_var_574, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_574));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_575;
                memcpy((uint64_t*)&cgen_var_575, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_575));
                uint64_t cgen_var_576;
                memcpy((uint64_t*)&cgen_var_576, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_576));
                memcpy((uint32_t*)&set, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)pData);
                }
                vk->vkCmdPushDescriptorSetWithTemplateKHR(unboxed_commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                android::base::beginTrace("vkCreateDescriptorUpdateTemplateKHR decode");
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_578;
                memcpy((uint64_t*)&cgen_var_578, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_578));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_580;
                memcpy((uint64_t*)&cgen_var_580, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_580));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplateKHR(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_581;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requires VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                android::base::beginTrace("vkDestroyDescriptorUpdateTemplateKHR decode");
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_582;
                memcpy((uint64_t*)&cgen_var_582, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_582));
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
                uint64_t cgen_var_583;
                memcpy((uint64_t*)&cgen_var_583, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_583));
                boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                descriptorUpdateTemplate = unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplateKHR(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplateKHR decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_585;
                memcpy((uint64_t*)&cgen_var_585, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_585));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_586;
                memcpy((uint64_t*)&cgen_var_586, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_586));
                uint64_t cgen_var_587;
                memcpy((uint64_t*)&cgen_var_587, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_587));
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                android::base::beginTrace("vkCreateRenderPass2KHR decode");
                VkDevice device;
                const VkRenderPassCreateInfo2KHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_589;
                memcpy((uint64_t*)&cgen_var_589, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_589));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
                reservedunmarshal_VkRenderPassCreateInfo2KHR(vkReadStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_591;
                memcpy((uint64_t*)&cgen_var_591, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkRenderPass*)pRenderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_591));
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo2KHR(m_state, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRenderPass2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = vk->vkCreateRenderPass2KHR(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_592;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_592, 1);
                vkStream->write((uint64_t*)&cgen_var_592, 8);
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass2KHR_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                android::base::beginTrace("vkCmdBeginRenderPass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_593;
                memcpy((uint64_t*)&cgen_var_593, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_593));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                reservedunmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo), readStreamPtrPtr);
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginRenderPass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)pSubpassBeginInfo);
                }
                vk->vkCmdBeginRenderPass2KHR(unboxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                android::base::beginTrace("vkCmdNextSubpass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_594;
                memcpy((uint64_t*)&cgen_var_594, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_594));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                reservedunmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                reservedunmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdNextSubpass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassBeginInfo, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                android::base::beginTrace("vkCmdEndRenderPass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_595;
                memcpy((uint64_t*)&cgen_var_595, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_595));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                reservedunmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndRenderPass2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                android::base::beginTrace("vkGetSwapchainStatusKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_596;
                memcpy((uint64_t*)&cgen_var_596, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_596));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_597;
                memcpy((uint64_t*)&cgen_var_597, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_597));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainStatusKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain);
                }
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = vk->vkGetSwapchainStatusKHR(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainStatusKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainStatusKHR_VkResult_return, device, swapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalFencePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_598;
                memcpy((uint64_t*)&cgen_var_598, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_598));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                reservedunmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties), readStreamPtrPtr);
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalFencePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFencePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                android::base::beginTrace("vkImportFenceWin32HandleKHR decode");
                VkDevice device;
                const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_599;
                memcpy((uint64_t*)&cgen_var_599, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_599));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                reservedunmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo), readStreamPtrPtr);
                if (pImportFenceWin32HandleInfo)
                {
                    transform_tohost_VkImportFenceWin32HandleInfoKHR(m_state, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportFenceWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceWin32HandleInfo);
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = vk->vkImportFenceWin32HandleKHR(unboxed_device, pImportFenceWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceWin32HandleKHR_VkResult_return, device, pImportFenceWin32HandleInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                android::base::beginTrace("vkGetFenceWin32HandleKHR decode");
                VkDevice device;
                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_600;
                memcpy((uint64_t*)&cgen_var_600, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_600));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                reservedunmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkFenceGetWin32HandleInfoKHR(m_state, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = vk->vkGetFenceWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                android::base::beginTrace("vkImportFenceFdKHR decode");
                VkDevice device;
                const VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_601;
                memcpy((uint64_t*)&cgen_var_601, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_601));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                reservedunmarshal_VkImportFenceFdInfoKHR(vkReadStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo), readStreamPtrPtr);
                if (pImportFenceFdInfo)
                {
                    transform_tohost_VkImportFenceFdInfoKHR(m_state, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportFenceFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceFdInfo);
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceFdKHR_VkResult_return, device, pImportFenceFdInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                android::base::beginTrace("vkGetFenceFdKHR decode");
                VkDevice device;
                const VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_602;
                memcpy((uint64_t*)&cgen_var_602, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_602));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                reservedunmarshal_VkFenceGetFdInfoKHR(vkReadStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkFenceGetFdInfoKHR(m_state, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilities2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_603;
                memcpy((uint64_t*)&cgen_var_603, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_603));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                reservedunmarshal_VkSurfaceCapabilities2KHR(vkReadStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceFormats2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_604;
                memcpy((uint64_t*)&cgen_var_604, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_604));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSurfaceFormatCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormatCount);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSurfaceFormatCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSurfaceFormat2KHR**)&pSurfaceFormats, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormats);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        reservedunmarshal_VkSurfaceFormat2KHR(vkReadStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), readStreamPtrPtr);
                    }
                }
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceFormats2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormats2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_607 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_607);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_608 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_608);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormats2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_609;
                memcpy((uint64_t*)&cgen_var_609, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_609));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayProperties2KHR(vkReadStream, (VkDisplayProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_612 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_612);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_613 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_613);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPlaneProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_614;
                memcpy((uint64_t*)&cgen_var_614, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_614));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPlaneProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPlaneProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_617 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_617);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_618 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_618);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                android::base::beginTrace("vkGetDisplayModeProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_619;
                memcpy((uint64_t*)&cgen_var_619, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_619));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_620;
                memcpy((uint64_t*)&cgen_var_620, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_620));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayModeProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayModeProperties2KHR(vkReadStream, (VkDisplayModeProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayModeProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = vk->vkGetDisplayModeProperties2KHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_623 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_623);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_624 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_624);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModeProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModeProperties2KHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneCapabilities2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_625;
                memcpy((uint64_t*)&cgen_var_625, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_625));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                reservedunmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                reservedunmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), readStreamPtrPtr);
                if (pDisplayPlaneInfo)
                {
                    transform_tohost_VkDisplayPlaneInfo2KHR(m_state, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                }
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pDisplayPlaneInfo, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = vk->vkGetDisplayPlaneCapabilities2KHR(unboxed_physicalDevice, pDisplayPlaneInfo, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilities2KHR_VkResult_return, physicalDevice, pDisplayPlaneInfo, pCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements2KHR decode");
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_626;
                memcpy((uint64_t*)&cgen_var_626, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_626));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                reservedunmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements2KHR decode");
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_627;
                memcpy((uint64_t*)&cgen_var_627, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_627));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                reservedunmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2KHR(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements2KHR decode");
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_628;
                memcpy((uint64_t*)&cgen_var_628, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_628));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_631 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_631);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_632 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_632);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                android::base::beginTrace("vkCreateSamplerYcbcrConversionKHR decode");
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_633;
                memcpy((uint64_t*)&cgen_var_633, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_633));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_635;
                memcpy((uint64_t*)&cgen_var_635, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSamplerYcbcrConversion*)pYcbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_635));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = vk->vkCreateSamplerYcbcrConversionKHR(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversionKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_636;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requires VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversionKHR_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                android::base::beginTrace("vkDestroySamplerYcbcrConversionKHR decode");
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_637;
                memcpy((uint64_t*)&cgen_var_637, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_637));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                uint64_t cgen_var_638;
                memcpy((uint64_t*)&cgen_var_638, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSamplerYcbcrConversion*)&ycbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_638));
                boxed_ycbcrConversion_preserve = ycbcrConversion;
                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversionKHR(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_ycbcrConversion_preserve, pAllocator);
                }
                delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                android::base::beginTrace("vkBindBufferMemory2KHR decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_640;
                memcpy((uint64_t*)&cgen_var_640, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_640));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_state->on_vkBindBufferMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                android::base::beginTrace("vkBindImageMemory2KHR decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_641;
                memcpy((uint64_t*)&cgen_var_641, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_641));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = vk->vkBindImageMemory2KHR(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                android::base::beginTrace("vkGetDescriptorSetLayoutSupportKHR decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_642;
                memcpy((uint64_t*)&cgen_var_642, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_642));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                reservedunmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDescriptorSetLayoutSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                android::base::beginTrace("vkCmdDrawIndirectCountKHR decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_643;
                memcpy((uint64_t*)&cgen_var_643, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_643));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_644;
                memcpy((uint64_t*)&cgen_var_644, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_644));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_645;
                memcpy((uint64_t*)&cgen_var_645, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_645));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirectCountKHR decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_646;
                memcpy((uint64_t*)&cgen_var_646, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_646));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_647;
                memcpy((uint64_t*)&cgen_var_647, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_647));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_648;
                memcpy((uint64_t*)&cgen_var_648, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_648));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_ANDROID_native_buffer
            case OP_vkGetSwapchainGrallocUsageANDROID:
            {
                android::base::beginTrace("vkGetSwapchainGrallocUsageANDROID decode");
                VkDevice device;
                VkFormat format;
                VkImageUsageFlags imageUsage;
                int* grallocUsage;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_649;
                memcpy((uint64_t*)&cgen_var_649, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_649));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageUsageFlags*)&imageUsage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                // Begin manual dispatchable handle unboxing for grallocUsage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&grallocUsage, sizeof(int));
                memcpy((int*)grallocUsage, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainGrallocUsageANDROID 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)format, (unsigned long long)imageUsage, (unsigned long long)grallocUsage);
                }
                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
                vkGetSwapchainGrallocUsageANDROID_VkResult_return = m_state->on_vkGetSwapchainGrallocUsageANDROID(&m_pool, device, format, imageUsage, grallocUsage);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)grallocUsage, sizeof(int));
                vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainGrallocUsageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainGrallocUsageANDROID_VkResult_return, device, format, imageUsage, grallocUsage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireImageANDROID:
            {
                android::base::beginTrace("vkAcquireImageANDROID decode");
                VkDevice device;
                VkImage image;
                int nativeFenceFd;
                VkSemaphore semaphore;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_650;
                memcpy((uint64_t*)&cgen_var_650, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_650));
                uint64_t cgen_var_651;
                memcpy((uint64_t*)&cgen_var_651, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_651));
                memcpy((int*)&nativeFenceFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                uint64_t cgen_var_652;
                memcpy((uint64_t*)&cgen_var_652, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_652));
                uint64_t cgen_var_653;
                memcpy((uint64_t*)&cgen_var_653, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_653));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)nativeFenceFd, (unsigned long long)semaphore, (unsigned long long)fence);
                }
                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(&m_pool, device, image, nativeFenceFd, semaphore, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireImageANDROID_VkResult_return, device, image, nativeFenceFd, semaphore, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROID:
            {
                android::base::beginTrace("vkQueueSignalReleaseImageANDROID decode");
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                int* pNativeFenceFd;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_654;
                memcpy((uint64_t*)&cgen_var_654, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_654));
                memcpy((uint32_t*)&waitSemaphoreCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkSemaphore**)&pWaitSemaphores, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pWaitSemaphores);
                *readStreamPtrPtr += 8;
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint8_t* cgen_var_656_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((waitSemaphoreCount));
                        for (uint32_t k = 0; k < ((waitSemaphoreCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_656_ptr + k * 8, sizeof(uint64_t));
                            *(((VkSemaphore*)pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
                        }
                    }
                }
                uint64_t cgen_var_657;
                memcpy((uint64_t*)&cgen_var_657, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_657));
                // Begin manual dispatchable handle unboxing for pNativeFenceFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pNativeFenceFd, sizeof(int));
                memcpy((int*)pNativeFenceFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSignalReleaseImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)waitSemaphoreCount, (unsigned long long)pWaitSemaphores, (unsigned long long)image, (unsigned long long)pNativeFenceFd);
                }
                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
                vkQueueSignalReleaseImageANDROID_VkResult_return = m_state->on_vkQueueSignalReleaseImageANDROID(&m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pNativeFenceFd, sizeof(int));
                vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSignalReleaseImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSignalReleaseImageANDROID_VkResult_return, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                android::base::beginTrace("vkCreateDebugReportCallbackEXT decode");
                VkInstance instance;
                const VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_658;
                memcpy((uint64_t*)&cgen_var_658, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_658));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pCallback;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                uint64_t cgen_var_660;
                memcpy((uint64_t*)&cgen_var_660, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDebugReportCallbackEXT*)pCallback = (VkDebugReportCallbackEXT)(VkDebugReportCallbackEXT)((VkDebugReportCallbackEXT)(*&cgen_var_660));
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugReportCallbackCreateInfoEXT(m_state, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCallback);
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = vk->vkCreateDebugReportCallbackEXT(unboxed_instance, pCreateInfo, pAllocator, pCallback);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pCallback;
                if (vkCreateDebugReportCallbackEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_661;
                static_assert(8 == sizeof(VkDebugReportCallbackEXT), "handle map overwrite requires VkDebugReportCallbackEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)pCallback, 1);
                vkStream->write((VkDebugReportCallbackEXT*)pCallback, 8 * 1);
                // Begin auto non dispatchable handle create for pCallback;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugReportCallbackEXT_VkResult_return, instance, pCreateInfo, pAllocator, pCallback);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                android::base::beginTrace("vkDestroyDebugReportCallbackEXT decode");
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_662;
                memcpy((uint64_t*)&cgen_var_662, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_662));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for callback;
                VkDebugReportCallbackEXT boxed_callback_preserve;
                uint64_t cgen_var_663;
                memcpy((uint64_t*)&cgen_var_663, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDebugReportCallbackEXT*)&callback = (VkDebugReportCallbackEXT)(VkDebugReportCallbackEXT)((VkDebugReportCallbackEXT)(*&cgen_var_663));
                boxed_callback_preserve = callback;
                callback = unbox_VkDebugReportCallbackEXT(callback);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)callback, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_callback_preserve, pAllocator);
                }
                delete_VkDebugReportCallbackEXT(boxed_callback_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                android::base::beginTrace("vkDebugReportMessageEXT decode");
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                const char* pLayerPrefix;
                const char* pMessage;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_665;
                memcpy((uint64_t*)&cgen_var_665, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_665));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                memcpy((VkDebugReportFlagsEXT*)&flags, *readStreamPtrPtr, sizeof(VkDebugReportFlagsEXT));
                *readStreamPtrPtr += sizeof(VkDebugReportFlagsEXT);
                memcpy((VkDebugReportObjectTypeEXT*)&objectType, *readStreamPtrPtr, sizeof(VkDebugReportObjectTypeEXT));
                *readStreamPtrPtr += sizeof(VkDebugReportObjectTypeEXT);
                memcpy((uint64_t*)&object, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                memcpy((size_t*)&location, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&location);
                *readStreamPtrPtr += 8;
                memcpy((int32_t*)&messageCode, *readStreamPtrPtr, sizeof(int32_t));
                *readStreamPtrPtr += sizeof(int32_t);
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerPrefix, readStreamPtrPtr);
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pMessage, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugReportMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)flags, (unsigned long long)objectType, (unsigned long long)object, (unsigned long long)location, (unsigned long long)messageCode, (unsigned long long)pLayerPrefix, (unsigned long long)pMessage);
                }
                vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugReportMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                android::base::beginTrace("vkDebugMarkerSetObjectTagEXT decode");
                VkDevice device;
                const VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_667;
                memcpy((uint64_t*)&cgen_var_667, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_667));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                reservedunmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo), readStreamPtrPtr);
                if (pTagInfo)
                {
                    transform_tohost_VkDebugMarkerObjectTagInfoEXT(m_state, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugMarkerSetObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = vk->vkDebugMarkerSetObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                android::base::beginTrace("vkDebugMarkerSetObjectNameEXT decode");
                VkDevice device;
                const VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_668;
                memcpy((uint64_t*)&cgen_var_668, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_668));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                reservedunmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo), readStreamPtrPtr);
                if (pNameInfo)
                {
                    transform_tohost_VkDebugMarkerObjectNameInfoEXT(m_state, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugMarkerSetObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = vk->vkDebugMarkerSetObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerBeginEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_669;
                memcpy((uint64_t*)&cgen_var_669, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_669));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                reservedunmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerBeginEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerBeginEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerBeginEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerEndEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_670;
                memcpy((uint64_t*)&cgen_var_670, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_670));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerEndEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdDebugMarkerEndEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerEndEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerInsertEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_671;
                memcpy((uint64_t*)&cgen_var_671, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_671));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                reservedunmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerInsertEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerInsertEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerInsertEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                android::base::beginTrace("vkCmdDrawIndirectCountAMD decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_672;
                memcpy((uint64_t*)&cgen_var_672, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_672));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_673;
                memcpy((uint64_t*)&cgen_var_673, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_673));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_674;
                memcpy((uint64_t*)&cgen_var_674, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_674));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirectCountAMD decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_675;
                memcpy((uint64_t*)&cgen_var_675, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_675));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_676;
                memcpy((uint64_t*)&cgen_var_676, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_676));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_677;
                memcpy((uint64_t*)&cgen_var_677, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_677));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                android::base::beginTrace("vkGetShaderInfoAMD decode");
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_678;
                memcpy((uint64_t*)&cgen_var_678, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_678));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_679;
                memcpy((uint64_t*)&cgen_var_679, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_679));
                memcpy((VkShaderStageFlagBits*)&shaderStage, *readStreamPtrPtr, sizeof(VkShaderStageFlagBits));
                *readStreamPtrPtr += sizeof(VkShaderStageFlagBits);
                memcpy((VkShaderInfoTypeAMD*)&infoType, *readStreamPtrPtr, sizeof(VkShaderInfoTypeAMD));
                *readStreamPtrPtr += sizeof(VkShaderInfoTypeAMD);
                // Begin manual dispatchable handle unboxing for pInfoSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pInfoSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInfoSize);
                *readStreamPtrPtr += 8;
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    memcpy((size_t*)&(*pInfoSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pInfoSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pInfo;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pInfo, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInfo);
                *readStreamPtrPtr += 8;
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    memcpy((void*)pInfo, *readStreamPtrPtr, (*(pInfoSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pInfoSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetShaderInfoAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)shaderStage, (unsigned long long)infoType, (unsigned long long)pInfoSize, (unsigned long long)pInfo);
                }
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = vk->vkGetShaderInfoAMD(unboxed_device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_683 = (uint64_t)(uintptr_t)pInfoSize;
                vkStream->putBe64(cgen_var_683);
                if (pInfoSize)
                {
                    uint64_t cgen_var_684 = (uint64_t)(*pInfoSize);
                    vkStream->putBe64(cgen_var_684);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_685 = (uint64_t)(uintptr_t)pInfo;
                vkStream->putBe64(cgen_var_685);
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetShaderInfoAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetShaderInfoAMD_VkResult_return, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalImageFormatPropertiesNV decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_686;
                memcpy((uint64_t*)&cgen_var_686, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_686));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageCreateFlags*)&flags, *readStreamPtrPtr, sizeof(VkImageCreateFlags));
                *readStreamPtrPtr += sizeof(VkImageCreateFlags);
                memcpy((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
                // Begin manual dispatchable handle unboxing for pExternalImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                reservedunmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), readStreamPtrPtr);
                if (pExternalImageFormatProperties)
                {
                    transform_tohost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalImageFormatPropertiesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)externalHandleType, (unsigned long long)pExternalImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(unboxed_physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pExternalImageFormatProperties)
                {
                    transform_fromhost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                android::base::beginTrace("vkGetMemoryWin32HandleNV decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_687;
                memcpy((uint64_t*)&cgen_var_687, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_687));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_688;
                memcpy((uint64_t*)&cgen_var_688, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_688));
                memcpy((VkExternalMemoryHandleTypeFlagsNV*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandleNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)handleType, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = vk->vkGetMemoryWin32HandleNV(unboxed_device, memory, handleType, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleNV_VkResult_return, device, memory, handleType, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                android::base::beginTrace("vkCreateViSurfaceNN decode");
                VkInstance instance;
                const VkViSurfaceCreateInfoNN* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_689;
                memcpy((uint64_t*)&cgen_var_689, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_689));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                reservedunmarshal_VkViSurfaceCreateInfoNN(vkReadStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_691;
                memcpy((uint64_t*)&cgen_var_691, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_691));
                if (pCreateInfo)
                {
                    transform_tohost_VkViSurfaceCreateInfoNN(m_state, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateViSurfaceNN 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = vk->vkCreateViSurfaceNN(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_692;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_692, 1);
                vkStream->write((uint64_t*)&cgen_var_692, 8);
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateViSurfaceNN(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateViSurfaceNN_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                android::base::beginTrace("vkCmdBeginConditionalRenderingEXT decode");
                VkCommandBuffer commandBuffer;
                const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_693;
                memcpy((uint64_t*)&cgen_var_693, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_693));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                reservedunmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin), readStreamPtrPtr);
                if (pConditionalRenderingBegin)
                {
                    transform_tohost_VkConditionalRenderingBeginInfoEXT(m_state, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginConditionalRenderingEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pConditionalRenderingBegin);
                }
                vk->vkCmdBeginConditionalRenderingEXT(unboxed_commandBuffer, pConditionalRenderingBegin);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pConditionalRenderingBegin);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                android::base::beginTrace("vkCmdEndConditionalRenderingEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_694;
                memcpy((uint64_t*)&cgen_var_694, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_694));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndConditionalRenderingEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndConditionalRenderingEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NVX_device_generated_commands
            case OP_vkCmdProcessCommandsNVX:
            {
                android::base::beginTrace("vkCmdProcessCommandsNVX decode");
                VkCommandBuffer commandBuffer;
                const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_695;
                memcpy((uint64_t*)&cgen_var_695, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_695));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
                reservedunmarshal_VkCmdProcessCommandsInfoNVX(vkReadStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo), readStreamPtrPtr);
                if (pProcessCommandsInfo)
                {
                    transform_tohost_VkCmdProcessCommandsInfoNVX(m_state, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdProcessCommandsNVX 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pProcessCommandsInfo);
                }
                vk->vkCmdProcessCommandsNVX(unboxed_commandBuffer, pProcessCommandsInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdProcessCommandsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pProcessCommandsInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdReserveSpaceForCommandsNVX:
            {
                android::base::beginTrace("vkCmdReserveSpaceForCommandsNVX decode");
                VkCommandBuffer commandBuffer;
                const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_696;
                memcpy((uint64_t*)&cgen_var_696, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_696));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
                reservedunmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkReadStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo), readStreamPtrPtr);
                if (pReserveSpaceInfo)
                {
                    transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(m_state, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdReserveSpaceForCommandsNVX 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pReserveSpaceInfo);
                }
                vk->vkCmdReserveSpaceForCommandsNVX(unboxed_commandBuffer, pReserveSpaceInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdReserveSpaceForCommandsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pReserveSpaceInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNVX:
            {
                android::base::beginTrace("vkCreateIndirectCommandsLayoutNVX decode");
                VkDevice device;
                const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_697;
                memcpy((uint64_t*)&cgen_var_697, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_697));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
                reservedunmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkReadStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pIndirectCommandsLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                uint64_t cgen_var_699;
                memcpy((uint64_t*)&cgen_var_699, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout = (VkIndirectCommandsLayoutNVX)(VkIndirectCommandsLayoutNVX)((VkIndirectCommandsLayoutNVX)(*&cgen_var_699));
                if (pCreateInfo)
                {
                    transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(m_state, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateIndirectCommandsLayoutNVX 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pIndirectCommandsLayout);
                }
                VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNVX_VkResult_return = vk->vkCreateIndirectCommandsLayoutNVX(unboxed_device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                if (vkCreateIndirectCommandsLayoutNVX_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_700;
                static_assert(8 == sizeof(VkIndirectCommandsLayoutNVX), "handle map overwrite requires VkIndirectCommandsLayoutNVX to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
                vkStream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 8 * 1);
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIndirectCommandsLayoutNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIndirectCommandsLayoutNVX_VkResult_return, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNVX:
            {
                android::base::beginTrace("vkDestroyIndirectCommandsLayoutNVX decode");
                VkDevice device;
                VkIndirectCommandsLayoutNVX indirectCommandsLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_701;
                memcpy((uint64_t*)&cgen_var_701, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_701));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                VkIndirectCommandsLayoutNVX boxed_indirectCommandsLayout_preserve;
                uint64_t cgen_var_702;
                memcpy((uint64_t*)&cgen_var_702, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout = (VkIndirectCommandsLayoutNVX)(VkIndirectCommandsLayoutNVX)((VkIndirectCommandsLayoutNVX)(*&cgen_var_702));
                boxed_indirectCommandsLayout_preserve = indirectCommandsLayout;
                indirectCommandsLayout = unbox_VkIndirectCommandsLayoutNVX(indirectCommandsLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyIndirectCommandsLayoutNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)indirectCommandsLayout, (unsigned long long)pAllocator);
                }
                vk->vkDestroyIndirectCommandsLayoutNVX(unboxed_device, indirectCommandsLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyIndirectCommandsLayoutNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_indirectCommandsLayout_preserve, pAllocator);
                }
                delete_VkIndirectCommandsLayoutNVX(boxed_indirectCommandsLayout_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateObjectTableNVX:
            {
                android::base::beginTrace("vkCreateObjectTableNVX decode");
                VkDevice device;
                const VkObjectTableCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkObjectTableNVX* pObjectTable;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_704;
                memcpy((uint64_t*)&cgen_var_704, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_704));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
                reservedunmarshal_VkObjectTableCreateInfoNVX(vkReadStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pObjectTable;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pObjectTable, sizeof(VkObjectTableNVX));
                uint64_t cgen_var_706;
                memcpy((uint64_t*)&cgen_var_706, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkObjectTableNVX*)pObjectTable = (VkObjectTableNVX)(VkObjectTableNVX)((VkObjectTableNVX)(*&cgen_var_706));
                if (pCreateInfo)
                {
                    transform_tohost_VkObjectTableCreateInfoNVX(m_state, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateObjectTableNVX 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pObjectTable);
                }
                VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
                vkCreateObjectTableNVX_VkResult_return = vk->vkCreateObjectTableNVX(unboxed_device, pCreateInfo, pAllocator, pObjectTable);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pObjectTable;
                if (vkCreateObjectTableNVX_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_707;
                static_assert(8 == sizeof(VkObjectTableNVX), "handle map overwrite requires VkObjectTableNVX to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkObjectTableNVX((VkObjectTableNVX*)pObjectTable, 1);
                vkStream->write((VkObjectTableNVX*)pObjectTable, 8 * 1);
                // Begin auto non dispatchable handle create for pObjectTable;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateObjectTableNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateObjectTableNVX_VkResult_return, device, pCreateInfo, pAllocator, pObjectTable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyObjectTableNVX:
            {
                android::base::beginTrace("vkDestroyObjectTableNVX decode");
                VkDevice device;
                VkObjectTableNVX objectTable;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_708;
                memcpy((uint64_t*)&cgen_var_708, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_708));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for objectTable;
                VkObjectTableNVX boxed_objectTable_preserve;
                uint64_t cgen_var_709;
                memcpy((uint64_t*)&cgen_var_709, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkObjectTableNVX*)&objectTable = (VkObjectTableNVX)(VkObjectTableNVX)((VkObjectTableNVX)(*&cgen_var_709));
                boxed_objectTable_preserve = objectTable;
                objectTable = unbox_VkObjectTableNVX(objectTable);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyObjectTableNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)pAllocator);
                }
                vk->vkDestroyObjectTableNVX(unboxed_device, objectTable, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyObjectTableNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_objectTable_preserve, pAllocator);
                }
                delete_VkObjectTableNVX(boxed_objectTable_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterObjectsNVX:
            {
                android::base::beginTrace("vkRegisterObjectsNVX decode");
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectTableEntryNVX* const* ppObjectTableEntries;
                const uint32_t* pObjectIndices;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_711;
                memcpy((uint64_t*)&cgen_var_711, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_711));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_712;
                memcpy((uint64_t*)&cgen_var_712, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkObjectTableNVX*)&objectTable = (VkObjectTableNVX)unbox_VkObjectTableNVX((VkObjectTableNVX)(*&cgen_var_712));
                memcpy((uint32_t*)&objectCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pObjectIndices, *readStreamPtrPtr, ((objectCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((objectCount)) * sizeof(const uint32_t);
                (void)ppObjectTableEntries;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterObjectsNVX 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)objectCount, (unsigned long long)ppObjectTableEntries, (unsigned long long)pObjectIndices);
                }
                VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
                vkRegisterObjectsNVX_VkResult_return = vk->vkRegisterObjectsNVX(unboxed_device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterObjectsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterObjectsNVX_VkResult_return, device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUnregisterObjectsNVX:
            {
                android::base::beginTrace("vkUnregisterObjectsNVX decode");
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectEntryTypeNVX* pObjectEntryTypes;
                const uint32_t* pObjectIndices;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_713;
                memcpy((uint64_t*)&cgen_var_713, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_713));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_714;
                memcpy((uint64_t*)&cgen_var_714, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkObjectTableNVX*)&objectTable = (VkObjectTableNVX)unbox_VkObjectTableNVX((VkObjectTableNVX)(*&cgen_var_714));
                memcpy((uint32_t*)&objectCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                memcpy((VkObjectEntryTypeNVX*)pObjectEntryTypes, *readStreamPtrPtr, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                *readStreamPtrPtr += ((objectCount)) * sizeof(const VkObjectEntryTypeNVX);
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pObjectIndices, *readStreamPtrPtr, ((objectCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((objectCount)) * sizeof(const uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUnregisterObjectsNVX 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)objectCount, (unsigned long long)pObjectEntryTypes, (unsigned long long)pObjectIndices);
                }
                VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
                vkUnregisterObjectsNVX_VkResult_return = vk->vkUnregisterObjectsNVX(unboxed_device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUnregisterObjectsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkUnregisterObjectsNVX_VkResult_return, device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX:
            {
                android::base::beginTrace("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX decode");
                VkPhysicalDevice physicalDevice;
                VkDeviceGeneratedCommandsFeaturesNVX* pFeatures;
                VkDeviceGeneratedCommandsLimitsNVX* pLimits;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_715;
                memcpy((uint64_t*)&cgen_var_715, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_715));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
                reservedunmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkReadStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pLimits;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLimits, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
                reservedunmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkReadStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                if (pLimits)
                {
                    transform_tohost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures, (unsigned long long)pLimits);
                }
                vk->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(unboxed_physicalDevice, pFeatures, pLimits);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                if (pLimits)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures, pLimits);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                android::base::beginTrace("vkCmdSetViewportWScalingNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewportWScalingNV* pViewportWScalings;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_716;
                memcpy((uint64_t*)&cgen_var_716, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_716));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkViewportWScalingNV(vkReadStream, (VkViewportWScalingNV*)(pViewportWScalings + i), readStreamPtrPtr);
                }
                if (pViewportWScalings)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewportWScalingNV(m_state, (VkViewportWScalingNV*)(pViewportWScalings + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewportWScalingNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewportWScalings);
                }
                vk->vkCmdSetViewportWScalingNV(unboxed_commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewportWScalingNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                android::base::beginTrace("vkReleaseDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_717;
                memcpy((uint64_t*)&cgen_var_717, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_717));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_718;
                memcpy((uint64_t*)&cgen_var_718, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_718));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkReleaseDisplayEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display);
                }
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = vk->vkReleaseDisplayEXT(unboxed_physicalDevice, display);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleaseDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkReleaseDisplayEXT_VkResult_return, physicalDevice, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                android::base::beginTrace("vkAcquireXlibDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_719;
                memcpy((uint64_t*)&cgen_var_719, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_719));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                uint64_t cgen_var_720;
                memcpy((uint64_t*)&cgen_var_720, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_720));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireXlibDisplayEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)display);
                }
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = vk->vkAcquireXlibDisplayEXT(unboxed_physicalDevice, dpy, display);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireXlibDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireXlibDisplayEXT_VkResult_return, physicalDevice, dpy, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                android::base::beginTrace("vkGetRandROutputDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_721;
                memcpy((uint64_t*)&cgen_var_721, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_721));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                memcpy((RROutput*)&rrOutput, *readStreamPtrPtr, sizeof(RROutput));
                *readStreamPtrPtr += sizeof(RROutput);
                // Begin manual dispatchable handle unboxing for pDisplay;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                uint64_t cgen_var_722;
                memcpy((uint64_t*)&cgen_var_722, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDisplayKHR*)pDisplay = (VkDisplayKHR)(VkDisplayKHR)((VkDisplayKHR)(*&cgen_var_722));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRandROutputDisplayEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)rrOutput, (unsigned long long)pDisplay);
                }
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = vk->vkGetRandROutputDisplayEXT(unboxed_physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_723;
                vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_723, 1);
                vkStream->write((uint64_t*)&cgen_var_723, 8);
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRandROutputDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRandROutputDisplayEXT_VkResult_return, physicalDevice, dpy, rrOutput, pDisplay);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilities2EXT decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_724;
                memcpy((uint64_t*)&cgen_var_724, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_724));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_725;
                memcpy((uint64_t*)&cgen_var_725, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_725));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                reservedunmarshal_VkSurfaceCapabilities2EXT(vkReadStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2EXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                android::base::beginTrace("vkDisplayPowerControlEXT decode");
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_726;
                memcpy((uint64_t*)&cgen_var_726, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_726));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_727;
                memcpy((uint64_t*)&cgen_var_727, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_727));
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                reservedunmarshal_VkDisplayPowerInfoEXT(vkReadStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo), readStreamPtrPtr);
                if (pDisplayPowerInfo)
                {
                    transform_tohost_VkDisplayPowerInfoEXT(m_state, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDisplayPowerControlEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayPowerInfo);
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = vk->vkDisplayPowerControlEXT(unboxed_device, display, pDisplayPowerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDisplayPowerControlEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDisplayPowerControlEXT_VkResult_return, device, display, pDisplayPowerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                android::base::beginTrace("vkRegisterDeviceEventEXT decode");
                VkDevice device;
                const VkDeviceEventInfoEXT* pDeviceEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_728;
                memcpy((uint64_t*)&cgen_var_728, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_728));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                reservedunmarshal_VkDeviceEventInfoEXT(vkReadStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_730;
                memcpy((uint64_t*)&cgen_var_730, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_730));
                if (pDeviceEventInfo)
                {
                    transform_tohost_VkDeviceEventInfoEXT(m_state, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterDeviceEventEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = vk->vkRegisterDeviceEventEXT(unboxed_device, pDeviceEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_731;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_731, 1);
                vkStream->write((uint64_t*)&cgen_var_731, 8);
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDeviceEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDeviceEventEXT_VkResult_return, device, pDeviceEventInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                android::base::beginTrace("vkRegisterDisplayEventEXT decode");
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayEventInfoEXT* pDisplayEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_732;
                memcpy((uint64_t*)&cgen_var_732, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_732));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_733;
                memcpy((uint64_t*)&cgen_var_733, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_733));
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                reservedunmarshal_VkDisplayEventInfoEXT(vkReadStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_735;
                memcpy((uint64_t*)&cgen_var_735, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_735));
                if (pDisplayEventInfo)
                {
                    transform_tohost_VkDisplayEventInfoEXT(m_state, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterDisplayEventEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = vk->vkRegisterDisplayEventEXT(unboxed_device, display, pDisplayEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_736;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_736, 1);
                vkStream->write((uint64_t*)&cgen_var_736, 8);
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDisplayEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDisplayEventEXT_VkResult_return, device, display, pDisplayEventInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                android::base::beginTrace("vkGetSwapchainCounterEXT decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_737;
                memcpy((uint64_t*)&cgen_var_737, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_737));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_738;
                memcpy((uint64_t*)&cgen_var_738, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_738));
                memcpy((VkSurfaceCounterFlagBitsEXT*)&counter, *readStreamPtrPtr, sizeof(VkSurfaceCounterFlagBitsEXT));
                *readStreamPtrPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
                // Begin manual dispatchable handle unboxing for pCounterValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                memcpy((uint64_t*)pCounterValue, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainCounterEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)counter, (unsigned long long)pCounterValue);
                }
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = vk->vkGetSwapchainCounterEXT(unboxed_device, swapchain, counter, pCounterValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainCounterEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainCounterEXT_VkResult_return, device, swapchain, counter, pCounterValue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                android::base::beginTrace("vkGetRefreshCycleDurationGOOGLE decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_739;
                memcpy((uint64_t*)&cgen_var_739, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_739));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_740;
                memcpy((uint64_t*)&cgen_var_740, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_740));
                // Begin manual dispatchable handle unboxing for pDisplayTimingProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                reservedunmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), readStreamPtrPtr);
                if (pDisplayTimingProperties)
                {
                    transform_tohost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRefreshCycleDurationGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pDisplayTimingProperties);
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = vk->vkGetRefreshCycleDurationGOOGLE(unboxed_device, swapchain, pDisplayTimingProperties);
                vkStream->unsetHandleMapping();
                if (pDisplayTimingProperties)
                {
                    transform_fromhost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRefreshCycleDurationGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRefreshCycleDurationGOOGLE_VkResult_return, device, swapchain, pDisplayTimingProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                android::base::beginTrace("vkGetPastPresentationTimingGOOGLE decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_741;
                memcpy((uint64_t*)&cgen_var_741, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_741));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_742;
                memcpy((uint64_t*)&cgen_var_742, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_742));
                // Begin manual dispatchable handle unboxing for pPresentationTimingCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPresentationTimingCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentationTimingCount);
                *readStreamPtrPtr += 8;
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPresentationTimingCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPresentationTimings;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentationTimings);
                *readStreamPtrPtr += 8;
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        reservedunmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), readStreamPtrPtr);
                    }
                }
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_tohost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPastPresentationTimingGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pPresentationTimingCount, (unsigned long long)pPresentationTimings);
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = vk->vkGetPastPresentationTimingGOOGLE(unboxed_device, swapchain, pPresentationTimingCount, pPresentationTimings);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_745 = (uint64_t)(uintptr_t)pPresentationTimingCount;
                vkStream->putBe64(cgen_var_745);
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_fromhost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_746 = (uint64_t)(uintptr_t)pPresentationTimings;
                vkStream->putBe64(cgen_var_746);
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPastPresentationTimingGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPastPresentationTimingGOOGLE_VkResult_return, device, swapchain, pPresentationTimingCount, pPresentationTimings);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                android::base::beginTrace("vkCmdSetDiscardRectangleEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                const VkRect2D* pDiscardRectangles;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_747;
                memcpy((uint64_t*)&cgen_var_747, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_747));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstDiscardRectangle, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&discardRectangleCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pDiscardRectangles + i), readStreamPtrPtr);
                }
                if (pDiscardRectangles)
                {
                    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pDiscardRectangles + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDiscardRectangleEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstDiscardRectangle, (unsigned long long)discardRectangleCount, (unsigned long long)pDiscardRectangles);
                }
                vk->vkCmdSetDiscardRectangleEXT(unboxed_commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDiscardRectangleEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                android::base::beginTrace("vkSetHdrMetadataEXT decode");
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainKHR* pSwapchains;
                const VkHdrMetadataEXT* pMetadata;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_748;
                memcpy((uint64_t*)&cgen_var_748, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_748));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&swapchainCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint8_t* cgen_var_749_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((swapchainCount));
                    for (uint32_t k = 0; k < ((swapchainCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_749_ptr + k * 8, sizeof(uint64_t));
                        *(((VkSwapchainKHR*)pSwapchains) + k) = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    reservedunmarshal_VkHdrMetadataEXT(vkReadStream, (VkHdrMetadataEXT*)(pMetadata + i), readStreamPtrPtr);
                }
                if (pMetadata)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkHdrMetadataEXT(m_state, (VkHdrMetadataEXT*)(pMetadata + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetHdrMetadataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pSwapchains, (unsigned long long)pMetadata);
                }
                vk->vkSetHdrMetadataEXT(unboxed_device, swapchainCount, pSwapchains, pMetadata);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetHdrMetadataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, swapchainCount, pSwapchains, pMetadata);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                android::base::beginTrace("vkCreateIOSSurfaceMVK decode");
                VkInstance instance;
                const VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_750;
                memcpy((uint64_t*)&cgen_var_750, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_750));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                reservedunmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_752;
                memcpy((uint64_t*)&cgen_var_752, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_752));
                if (pCreateInfo)
                {
                    transform_tohost_VkIOSSurfaceCreateInfoMVK(m_state, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateIOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = vk->vkCreateIOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_753;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_753, 1);
                vkStream->write((uint64_t*)&cgen_var_753, 8);
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                android::base::beginTrace("vkCreateMacOSSurfaceMVK decode");
                VkInstance instance;
                const VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_754;
                memcpy((uint64_t*)&cgen_var_754, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_754));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                reservedunmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_756;
                memcpy((uint64_t*)&cgen_var_756, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_756));
                if (pCreateInfo)
                {
                    transform_tohost_VkMacOSSurfaceCreateInfoMVK(m_state, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateMacOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = vk->vkCreateMacOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_757;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_757, 1);
                vkStream->write((uint64_t*)&cgen_var_757, 8);
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateMacOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateMacOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                android::base::beginTrace("vkSetDebugUtilsObjectNameEXT decode");
                VkDevice device;
                const VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_758;
                memcpy((uint64_t*)&cgen_var_758, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_758));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo), readStreamPtrPtr);
                if (pNameInfo)
                {
                    transform_tohost_VkDebugUtilsObjectNameInfoEXT(m_state, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                android::base::beginTrace("vkSetDebugUtilsObjectTagEXT decode");
                VkDevice device;
                const VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_759;
                memcpy((uint64_t*)&cgen_var_759, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_759));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                reservedunmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo), readStreamPtrPtr);
                if (pTagInfo)
                {
                    transform_tohost_VkDebugUtilsObjectTagInfoEXT(m_state, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueBeginDebugUtilsLabelEXT decode");
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_760;
                memcpy((uint64_t*)&cgen_var_760, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_760));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueEndDebugUtilsLabelEXT decode");
                VkQueue queue;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_761;
                memcpy((uint64_t*)&cgen_var_761, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_761));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueInsertDebugUtilsLabelEXT decode");
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_762;
                memcpy((uint64_t*)&cgen_var_762, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_762));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdBeginDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_763;
                memcpy((uint64_t*)&cgen_var_763, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_763));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdEndDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_764;
                memcpy((uint64_t*)&cgen_var_764, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_764));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdInsertDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_765;
                memcpy((uint64_t*)&cgen_var_765, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_765));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                android::base::beginTrace("vkCreateDebugUtilsMessengerEXT decode");
                VkInstance instance;
                const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_766;
                memcpy((uint64_t*)&cgen_var_766, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_766));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMessenger;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                uint64_t cgen_var_768;
                memcpy((uint64_t*)&cgen_var_768, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDebugUtilsMessengerEXT*)pMessenger = (VkDebugUtilsMessengerEXT)(VkDebugUtilsMessengerEXT)((VkDebugUtilsMessengerEXT)(*&cgen_var_768));
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(m_state, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMessenger);
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = vk->vkCreateDebugUtilsMessengerEXT(unboxed_instance, pCreateInfo, pAllocator, pMessenger);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMessenger;
                if (vkCreateDebugUtilsMessengerEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_769;
                static_assert(8 == sizeof(VkDebugUtilsMessengerEXT), "handle map overwrite requires VkDebugUtilsMessengerEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)pMessenger, 1);
                vkStream->write((VkDebugUtilsMessengerEXT*)pMessenger, 8 * 1);
                // Begin auto non dispatchable handle create for pMessenger;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugUtilsMessengerEXT_VkResult_return, instance, pCreateInfo, pAllocator, pMessenger);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                android::base::beginTrace("vkDestroyDebugUtilsMessengerEXT decode");
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_770;
                memcpy((uint64_t*)&cgen_var_770, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_770));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for messenger;
                VkDebugUtilsMessengerEXT boxed_messenger_preserve;
                uint64_t cgen_var_771;
                memcpy((uint64_t*)&cgen_var_771, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDebugUtilsMessengerEXT*)&messenger = (VkDebugUtilsMessengerEXT)(VkDebugUtilsMessengerEXT)((VkDebugUtilsMessengerEXT)(*&cgen_var_771));
                boxed_messenger_preserve = messenger;
                messenger = unbox_VkDebugUtilsMessengerEXT(messenger);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messenger, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_messenger_preserve, pAllocator);
                }
                delete_VkDebugUtilsMessengerEXT(boxed_messenger_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                android::base::beginTrace("vkSubmitDebugUtilsMessageEXT decode");
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_773;
                memcpy((uint64_t*)&cgen_var_773, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_773));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                memcpy((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, *readStreamPtrPtr, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                *readStreamPtrPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
                memcpy((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, *readStreamPtrPtr, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                *readStreamPtrPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                reservedunmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData), readStreamPtrPtr);
                if (pCallbackData)
                {
                    transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(m_state, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSubmitDebugUtilsMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messageSeverity, (unsigned long long)messageTypes, (unsigned long long)pCallbackData);
                }
                vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity, messageTypes, pCallbackData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSubmitDebugUtilsMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, messageSeverity, messageTypes, pCallbackData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                android::base::beginTrace("vkGetAndroidHardwareBufferPropertiesANDROID decode");
                VkDevice device;
                const AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_774;
                memcpy((uint64_t*)&cgen_var_774, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_774));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                memcpy((AHardwareBuffer*)buffer, *readStreamPtrPtr, sizeof(const AHardwareBuffer));
                *readStreamPtrPtr += sizeof(const AHardwareBuffer);
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                reservedunmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAndroidHardwareBufferPropertiesANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pProperties);
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = vk->vkGetAndroidHardwareBufferPropertiesANDROID(unboxed_device, buffer, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAndroidHardwareBufferPropertiesANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, device, buffer, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                android::base::beginTrace("vkGetMemoryAndroidHardwareBufferANDROID decode");
                VkDevice device;
                const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_775;
                memcpy((uint64_t*)&cgen_var_775, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_775));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                reservedunmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                memcpy((AHardwareBuffer**)pBuffer, *readStreamPtrPtr, sizeof(AHardwareBuffer*));
                *readStreamPtrPtr += sizeof(AHardwareBuffer*);
                if (pInfo)
                {
                    transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(m_state, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryAndroidHardwareBufferANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pBuffer);
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = vk->vkGetMemoryAndroidHardwareBufferANDROID(unboxed_device, pInfo, pBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryAndroidHardwareBufferANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, device, pInfo, pBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                android::base::beginTrace("vkCmdSetSampleLocationsEXT decode");
                VkCommandBuffer commandBuffer;
                const VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_776;
                memcpy((uint64_t*)&cgen_var_776, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_776));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                reservedunmarshal_VkSampleLocationsInfoEXT(vkReadStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo), readStreamPtrPtr);
                if (pSampleLocationsInfo)
                {
                    transform_tohost_VkSampleLocationsInfoEXT(m_state, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetSampleLocationsEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSampleLocationsInfo);
                }
                vk->vkCmdSetSampleLocationsEXT(unboxed_commandBuffer, pSampleLocationsInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetSampleLocationsEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSampleLocationsInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMultisamplePropertiesEXT decode");
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_777;
                memcpy((uint64_t*)&cgen_var_777, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_777));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkSampleCountFlagBits*)&samples, *readStreamPtrPtr, sizeof(VkSampleCountFlagBits));
                *readStreamPtrPtr += sizeof(VkSampleCountFlagBits);
                // Begin manual dispatchable handle unboxing for pMultisampleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                reservedunmarshal_VkMultisamplePropertiesEXT(vkReadStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), readStreamPtrPtr);
                if (pMultisampleProperties)
                {
                    transform_tohost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMultisamplePropertiesEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)samples, (unsigned long long)pMultisampleProperties);
                }
                vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(unboxed_physicalDevice, samples, pMultisampleProperties);
                vkStream->unsetHandleMapping();
                if (pMultisampleProperties)
                {
                    transform_fromhost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMultisamplePropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, samples, pMultisampleProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                android::base::beginTrace("vkCreateValidationCacheEXT decode");
                VkDevice device;
                const VkValidationCacheCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_778;
                memcpy((uint64_t*)&cgen_var_778, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_778));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                reservedunmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pValidationCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                uint64_t cgen_var_780;
                memcpy((uint64_t*)&cgen_var_780, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkValidationCacheEXT*)pValidationCache = (VkValidationCacheEXT)(VkValidationCacheEXT)((VkValidationCacheEXT)(*&cgen_var_780));
                if (pCreateInfo)
                {
                    transform_tohost_VkValidationCacheCreateInfoEXT(m_state, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateValidationCacheEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pValidationCache);
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = vk->vkCreateValidationCacheEXT(unboxed_device, pCreateInfo, pAllocator, pValidationCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pValidationCache;
                if (vkCreateValidationCacheEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_781;
                static_assert(8 == sizeof(VkValidationCacheEXT), "handle map overwrite requires VkValidationCacheEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)pValidationCache, 1);
                vkStream->write((VkValidationCacheEXT*)pValidationCache, 8 * 1);
                // Begin auto non dispatchable handle create for pValidationCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateValidationCacheEXT_VkResult_return, device, pCreateInfo, pAllocator, pValidationCache);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                android::base::beginTrace("vkDestroyValidationCacheEXT decode");
                VkDevice device;
                VkValidationCacheEXT validationCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_782;
                memcpy((uint64_t*)&cgen_var_782, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_782));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for validationCache;
                VkValidationCacheEXT boxed_validationCache_preserve;
                uint64_t cgen_var_783;
                memcpy((uint64_t*)&cgen_var_783, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&validationCache = (VkValidationCacheEXT)(VkValidationCacheEXT)((VkValidationCacheEXT)(*&cgen_var_783));
                boxed_validationCache_preserve = validationCache;
                validationCache = unbox_VkValidationCacheEXT(validationCache);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyValidationCacheEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyValidationCacheEXT(unboxed_device, validationCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_validationCache_preserve, pAllocator);
                }
                delete_VkValidationCacheEXT(boxed_validationCache_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                android::base::beginTrace("vkMergeValidationCachesEXT decode");
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                const VkValidationCacheEXT* pSrcCaches;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_785;
                memcpy((uint64_t*)&cgen_var_785, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_785));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_786;
                memcpy((uint64_t*)&cgen_var_786, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&dstCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_786));
                memcpy((uint32_t*)&srcCacheCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (((srcCacheCount)))
                {
                    uint8_t* cgen_var_787_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((srcCacheCount));
                    for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_787_ptr + k * 8, sizeof(uint64_t));
                        *(((VkValidationCacheEXT*)pSrcCaches) + k) = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMergeValidationCachesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = vk->vkMergeValidationCachesEXT(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergeValidationCachesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergeValidationCachesEXT_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                android::base::beginTrace("vkGetValidationCacheDataEXT decode");
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_788;
                memcpy((uint64_t*)&cgen_var_788, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_788));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_789;
                memcpy((uint64_t*)&cgen_var_789, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&validationCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_789));
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pDataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDataSize);
                *readStreamPtrPtr += 8;
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    memcpy((size_t*)&(*pDataSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pDataSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, (*(pDataSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetValidationCacheDataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = vk->vkGetValidationCacheDataEXT(unboxed_device, validationCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_793 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_793);
                if (pDataSize)
                {
                    uint64_t cgen_var_794 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_794);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_795 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_795);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetValidationCacheDataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetValidationCacheDataEXT_VkResult_return, device, validationCache, pDataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                android::base::beginTrace("vkGetMemoryHostPointerPropertiesEXT decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                const void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_796;
                memcpy((uint64_t*)&cgen_var_796, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_796));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                // WARNING PTR CHECK
                memcpy((void**)&pHostPointer, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pHostPointer);
                *readStreamPtrPtr += 8;
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    memcpy((void*)pHostPointer, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                // Begin manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                reservedunmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), readStreamPtrPtr);
                if (pMemoryHostPointerProperties)
                {
                    transform_tohost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryHostPointerPropertiesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)pHostPointer, (unsigned long long)pMemoryHostPointerProperties);
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vk->vkGetMemoryHostPointerPropertiesEXT(unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryHostPointerProperties)
                {
                    transform_fromhost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostPointerPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostPointerPropertiesEXT_VkResult_return, device, handleType, pHostPointer, pMemoryHostPointerProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                android::base::beginTrace("vkCmdWriteBufferMarkerAMD decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_798;
                memcpy((uint64_t*)&cgen_var_798, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_798));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineStageFlagBits*)&pipelineStage, *readStreamPtrPtr, sizeof(VkPipelineStageFlagBits));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlagBits);
                uint64_t cgen_var_799;
                memcpy((uint64_t*)&cgen_var_799, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_799));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&marker, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteBufferMarkerAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)marker);
                }
                vk->vkCmdWriteBufferMarkerAMD(unboxed_commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteBufferMarkerAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                android::base::beginTrace("vkCmdSetCheckpointNV decode");
                VkCommandBuffer commandBuffer;
                const void* pCheckpointMarker;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_800;
                memcpy((uint64_t*)&cgen_var_800, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_800));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                // WARNING PTR CHECK
                memcpy((void**)&pCheckpointMarker, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointMarker);
                *readStreamPtrPtr += 8;
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    memcpy((void*)pCheckpointMarker, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetCheckpointNV 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCheckpointMarker);
                }
                vk->vkCmdSetCheckpointNV(unboxed_commandBuffer, pCheckpointMarker);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetCheckpointNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCheckpointMarker);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                android::base::beginTrace("vkGetQueueCheckpointDataNV decode");
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_802;
                memcpy((uint64_t*)&cgen_var_802, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_802));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                // Begin manual dispatchable handle unboxing for pCheckpointDataCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pCheckpointDataCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointDataCount);
                *readStreamPtrPtr += 8;
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pCheckpointDataCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pCheckpointData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkCheckpointDataNV**)&pCheckpointData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointData);
                *readStreamPtrPtr += 8;
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        reservedunmarshal_VkCheckpointDataNV(vkReadStream, (VkCheckpointDataNV*)(pCheckpointData + i), readStreamPtrPtr);
                    }
                }
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_tohost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetQueueCheckpointDataNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pCheckpointDataCount, (unsigned long long)pCheckpointData);
                }
                vk->vkGetQueueCheckpointDataNV(unboxed_queue, pCheckpointDataCount, pCheckpointData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_805 = (uint64_t)(uintptr_t)pCheckpointDataCount;
                vkStream->putBe64(cgen_var_805);
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_fromhost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_806 = (uint64_t)(uintptr_t)pCheckpointData;
                vkStream->putBe64(cgen_var_806);
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueueCheckpointDataNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pCheckpointDataCount, pCheckpointData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space
            case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
            {
                android::base::beginTrace("vkMapMemoryIntoAddressSpaceGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_807;
                memcpy((uint64_t*)&cgen_var_807, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_807));
                uint64_t cgen_var_808;
                memcpy((uint64_t*)&cgen_var_808, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_808));
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pAddress, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAddress);
                *readStreamPtrPtr += 8;
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    memcpy((uint64_t*)pAddress, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMapMemoryIntoAddressSpaceGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress);
                }
                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, device, memory, pAddress);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_810 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_810);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemoryIntoAddressSpaceGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_color_buffer
            case OP_vkRegisterImageColorBufferGOOGLE:
            {
                android::base::beginTrace("vkRegisterImageColorBufferGOOGLE decode");
                VkDevice device;
                VkImage image;
                uint32_t colorBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_811;
                memcpy((uint64_t*)&cgen_var_811, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_811));
                uint64_t cgen_var_812;
                memcpy((uint64_t*)&cgen_var_812, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_812));
                memcpy((uint32_t*)&colorBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterImageColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterImageColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterImageColorBufferGOOGLE(&m_pool, device, image, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterImageColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterImageColorBufferGOOGLE_VkResult_return, device, image, colorBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterBufferColorBufferGOOGLE:
            {
                android::base::beginTrace("vkRegisterBufferColorBufferGOOGLE decode");
                VkDevice device;
                VkBuffer buffer;
                uint32_t colorBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_813;
                memcpy((uint64_t*)&cgen_var_813, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_813));
                uint64_t cgen_var_814;
                memcpy((uint64_t*)&cgen_var_814, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_814));
                memcpy((uint32_t*)&colorBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterBufferColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterBufferColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterBufferColorBufferGOOGLE(&m_pool, device, buffer, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterBufferColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterBufferColorBufferGOOGLE_VkResult_return, device, buffer, colorBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
            case OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplateSizedGOOGLE decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                uint32_t imageInfoCount;
                uint32_t bufferInfoCount;
                uint32_t bufferViewCount;
                const uint32_t* pImageInfoEntryIndices;
                const uint32_t* pBufferInfoEntryIndices;
                const uint32_t* pBufferViewEntryIndices;
                const VkDescriptorImageInfo* pImageInfos;
                const VkDescriptorBufferInfo* pBufferInfos;
                const VkBufferView* pBufferViews;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_815;
                memcpy((uint64_t*)&cgen_var_815, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_815));
                uint64_t cgen_var_816;
                memcpy((uint64_t*)&cgen_var_816, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_816));
                uint64_t cgen_var_817;
                memcpy((uint64_t*)&cgen_var_817, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_817));
                memcpy((uint32_t*)&imageInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bufferInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bufferViewCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pImageInfoEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pImageInfoEntryIndices);
                *readStreamPtrPtr += 8;
                if (pImageInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pImageInfoEntryIndices, *readStreamPtrPtr, ((imageInfoCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((imageInfoCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pBufferInfoEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferInfoEntryIndices);
                *readStreamPtrPtr += 8;
                if (pBufferInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pBufferInfoEntryIndices, *readStreamPtrPtr, ((bufferInfoCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((bufferInfoCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pBufferViewEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferViewEntryIndices);
                *readStreamPtrPtr += 8;
                if (pBufferViewEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pBufferViewEntryIndices, *readStreamPtrPtr, ((bufferViewCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((bufferViewCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((VkDescriptorImageInfo**)&pImageInfos, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pImageInfos);
                *readStreamPtrPtr += 8;
                if (pImageInfos)
                {
                    vkReadStream->alloc((void**)&pImageInfos, ((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        reservedunmarshal_VkDescriptorImageInfo(vkReadStream, (VkDescriptorImageInfo*)(pImageInfos + i), readStreamPtrPtr);
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDescriptorBufferInfo**)&pBufferInfos, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferInfos);
                *readStreamPtrPtr += 8;
                if (pBufferInfos)
                {
                    vkReadStream->alloc((void**)&pBufferInfos, ((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        reservedunmarshal_VkDescriptorBufferInfo(vkReadStream, (VkDescriptorBufferInfo*)(pBufferInfos + i), readStreamPtrPtr);
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkBufferView**)&pBufferViews, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferViews);
                *readStreamPtrPtr += 8;
                if (pBufferViews)
                {
                    vkReadStream->alloc((void**)&pBufferViews, ((bufferViewCount)) * sizeof(const VkBufferView));
                    if (((bufferViewCount)))
                    {
                        uint8_t* cgen_var_824_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((bufferViewCount));
                        for (uint32_t k = 0; k < ((bufferViewCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_824_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBufferView*)pBufferViews) + k) = (VkBufferView)unbox_VkBufferView((VkBufferView)tmpval);
                        }
                    }
                }
                if (pImageInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorImageInfo(m_state, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                if (pBufferInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorBufferInfo(m_state, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplateSizedGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)imageInfoCount, (unsigned long long)bufferInfoCount, (unsigned long long)bufferViewCount, (unsigned long long)pImageInfoEntryIndices, (unsigned long long)pBufferInfoEntryIndices, (unsigned long long)pBufferViewEntryIndices, (unsigned long long)pImageInfos, (unsigned long long)pBufferInfos, (unsigned long long)pBufferViews);
                }
                m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(&m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_async_command_buffers
            case OP_vkBeginCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkBeginCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_825;
                memcpy((uint64_t*)&cgen_var_825, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_825));
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo), readStreamPtrPtr);
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBeginCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEndCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkEndCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_826;
                memcpy((uint64_t*)&cgen_var_826, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_826));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEndCommandBufferAsyncGOOGLE 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkResetCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_827;
                memcpy((uint64_t*)&cgen_var_827, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_827));
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCommandBufferHostSyncGOOGLE:
            {
                android::base::beginTrace("vkCommandBufferHostSyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_828;
                memcpy((uint64_t*)&cgen_var_828, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_828));
                memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCommandBufferHostSyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                }
                m_state->on_vkCommandBufferHostSyncGOOGLE(&m_pool, commandBuffer, needHostSync, sequenceNumber);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCommandBufferHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, needHostSync, sequenceNumber);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
            case OP_vkCreateImageWithRequirementsGOOGLE:
            {
                android::base::beginTrace("vkCreateImageWithRequirementsGOOGLE decode");
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_829;
                memcpy((uint64_t*)&cgen_var_829, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_829));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                reservedunmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_831;
                memcpy((uint64_t*)&cgen_var_831, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImage*)pImage = (VkImage)(VkImage)((VkImage)(*&cgen_var_831));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImageWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateImageWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateImageWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_832;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requires VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBufferWithRequirementsGOOGLE:
            {
                android::base::beginTrace("vkCreateBufferWithRequirementsGOOGLE decode");
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_833;
                memcpy((uint64_t*)&cgen_var_833, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_833));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                reservedunmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_835;
                memcpy((uint64_t*)&cgen_var_835, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBuffer*)pBuffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_835));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBufferWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateBufferWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateBufferWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_836;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requires VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space_info
            case OP_vkGetMemoryHostAddressInfoGOOGLE:
            {
                android::base::beginTrace("vkGetMemoryHostAddressInfoGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                uint64_t* pSize;
                uint64_t* pHostmemId;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_837;
                memcpy((uint64_t*)&cgen_var_837, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_837));
                uint64_t cgen_var_838;
                memcpy((uint64_t*)&cgen_var_838, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_838));
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pAddress, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAddress);
                *readStreamPtrPtr += 8;
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    memcpy((uint64_t*)pAddress, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                // Begin manual dispatchable handle unboxing for pSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSize);
                *readStreamPtrPtr += 8;
                if (pSize)
                {
                    vkReadStream->alloc((void**)&pSize, sizeof(uint64_t));
                    memcpy((uint64_t*)pSize, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                // Begin manual dispatchable handle unboxing for pHostmemId;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pHostmemId, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pHostmemId);
                *readStreamPtrPtr += 8;
                if (pHostmemId)
                {
                    vkReadStream->alloc((void**)&pHostmemId, sizeof(uint64_t));
                    memcpy((uint64_t*)pHostmemId, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryHostAddressInfoGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress, (unsigned long long)pSize, (unsigned long long)pHostmemId);
                }
                VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
                vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = m_state->on_vkGetMemoryHostAddressInfoGOOGLE(&m_pool, device, memory, pAddress, pSize, pHostmemId);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_842 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_842);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_843 = (uint64_t)(uintptr_t)pSize;
                vkStream->putBe64(cgen_var_843);
                if (pSize)
                {
                    vkStream->write((uint64_t*)pSize, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_844 = (uint64_t)(uintptr_t)pHostmemId;
                vkStream->putBe64(cgen_var_844);
                if (pHostmemId)
                {
                    vkStream->write((uint64_t*)pHostmemId, sizeof(uint64_t));
                }
                vkStream->write(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostAddressInfoGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, device, memory, pAddress, pSize, pHostmemId);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_free_memory_sync
            case OP_vkFreeMemorySyncGOOGLE:
            {
                android::base::beginTrace("vkFreeMemorySyncGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_845;
                memcpy((uint64_t*)&cgen_var_845, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_845));
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory boxed_memory_preserve;
                uint64_t cgen_var_846;
                memcpy((uint64_t*)&cgen_var_846, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_846));
                boxed_memory_preserve = memory;
                memory = unbox_VkDeviceMemory(memory);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeMemorySyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
                vkFreeMemorySyncGOOGLE_VkResult_return = m_state->on_vkFreeMemorySyncGOOGLE(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemorySyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeMemorySyncGOOGLE_VkResult_return, device, boxed_memory_preserve, pAllocator);
                }
                delete_VkDeviceMemory(boxed_memory_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_async_queue_submit
            case OP_vkQueueHostSyncGOOGLE:
            {
                android::base::beginTrace("vkQueueHostSyncGOOGLE decode");
                VkQueue queue;
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_848;
                memcpy((uint64_t*)&cgen_var_848, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_848));
                memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueHostSyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                }
                m_state->on_vkQueueHostSyncGOOGLE(&m_pool, queue, needHostSync, sequenceNumber);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, needHostSync, sequenceNumber);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSubmitAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueSubmitAsyncGOOGLE decode");
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_849;
                memcpy((uint64_t*)&cgen_var_849, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_849));
                memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    reservedunmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_850;
                memcpy((uint64_t*)&cgen_var_850, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_850));
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSubmitAsyncGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)submitCount, (unsigned long long)pSubmits, (unsigned long long)fence);
                }
                m_state->on_vkQueueSubmitAsyncGOOGLE(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSubmitAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, submitCount, pSubmits, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueWaitIdleAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueWaitIdleAsyncGOOGLE decode");
                VkQueue queue;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_851;
                memcpy((uint64_t*)&cgen_var_851, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_851));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueWaitIdleAsyncGOOGLE 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                m_state->on_vkQueueWaitIdleAsyncGOOGLE(&m_pool, queue);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueWaitIdleAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBindSparseAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueBindSparseAsyncGOOGLE decode");
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_852;
                memcpy((uint64_t*)&cgen_var_852, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_852));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_853;
                memcpy((uint64_t*)&cgen_var_853, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_853));
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBindSparseAsyncGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfo, (unsigned long long)fence);
                }
                m_state->on_vkQueueBindSparseAsyncGOOGLE(&m_pool, queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBindSparseAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, bindInfoCount, pBindInfo, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_linear_image_layout
            case OP_vkGetLinearImageLayoutGOOGLE:
            {
                android::base::beginTrace("vkGetLinearImageLayoutGOOGLE decode");
                VkDevice device;
                VkFormat format;
                VkDeviceSize* pOffset;
                VkDeviceSize* pRowPitchAlignment;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_854;
                memcpy((uint64_t*)&cgen_var_854, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_854));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pOffset;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pOffset, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                // Begin manual dispatchable handle unboxing for pRowPitchAlignment;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRowPitchAlignment, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pRowPitchAlignment, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetLinearImageLayoutGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)format, (unsigned long long)pOffset, (unsigned long long)pRowPitchAlignment);
                }
                m_state->on_vkGetLinearImageLayoutGOOGLE(&m_pool, device, format, pOffset, pRowPitchAlignment);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
                vkStream->write((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetLinearImageLayoutGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, format, pOffset, pRowPitchAlignment);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_moltenvk
            case OP_vkGetMTLDeviceMVK:
            {
                android::base::beginTrace("vkGetMTLDeviceMVK decode");
                VkPhysicalDevice physicalDevice;
                void** pMTLDevice;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_855;
                memcpy((uint64_t*)&cgen_var_855, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_855));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMTLDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLDevice, sizeof(void*));
                memcpy((void**)pMTLDevice, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLDeviceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMTLDevice);
                }
                vk->vkGetMTLDeviceMVK(unboxed_physicalDevice, pMTLDevice);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLDevice, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLDeviceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMTLDevice);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetMTLTextureMVK:
            {
                android::base::beginTrace("vkSetMTLTextureMVK decode");
                VkImage image;
                void* mtlTexture;
                uint64_t cgen_var_856;
                memcpy((uint64_t*)&cgen_var_856, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_856));
                // Begin manual dispatchable handle unboxing for mtlTexture;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&mtlTexture, sizeof(uint8_t));
                memcpy((void*)mtlTexture, *readStreamPtrPtr, sizeof(uint8_t));
                *readStreamPtrPtr += sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetMTLTextureMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)mtlTexture);
                }
                VkResult vkSetMTLTextureMVK_VkResult_return = (VkResult)0;
                vkSetMTLTextureMVK_VkResult_return = vk->vkSetMTLTextureMVK(image, mtlTexture);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)mtlTexture, sizeof(uint8_t));
                vkStream->write(&vkSetMTLTextureMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetMTLTextureMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetMTLTextureMVK_VkResult_return, image, mtlTexture);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMTLTextureMVK:
            {
                android::base::beginTrace("vkGetMTLTextureMVK decode");
                VkImage image;
                void** pMTLTexture;
                uint64_t cgen_var_857;
                memcpy((uint64_t*)&cgen_var_857, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_857));
                // Begin manual dispatchable handle unboxing for pMTLTexture;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLTexture, sizeof(void*));
                memcpy((void**)pMTLTexture, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLTextureMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)pMTLTexture);
                }
                vk->vkGetMTLTextureMVK(image, pMTLTexture);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLTexture, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLTextureMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, image, pMTLTexture);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMTLBufferMVK:
            {
                android::base::beginTrace("vkGetMTLBufferMVK decode");
                VkBuffer buffer;
                void** pMTLBuffer;
                uint64_t cgen_var_858;
                memcpy((uint64_t*)&cgen_var_858, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_858));
                // Begin manual dispatchable handle unboxing for pMTLBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLBuffer, sizeof(void*));
                memcpy((void**)pMTLBuffer, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLBufferMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)buffer, (unsigned long long)pMTLBuffer);
                }
                vk->vkGetMTLBufferMVK(buffer, pMTLBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLBuffer, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLBufferMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, buffer, pMTLBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUseIOSurfaceMVK:
            {
                android::base::beginTrace("vkUseIOSurfaceMVK decode");
                VkImage image;
                void* ioSurface;
                uint64_t cgen_var_859;
                memcpy((uint64_t*)&cgen_var_859, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_859));
                // Begin manual dispatchable handle unboxing for ioSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&ioSurface, sizeof(uint8_t));
                memcpy((void*)ioSurface, *readStreamPtrPtr, sizeof(uint8_t));
                *readStreamPtrPtr += sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUseIOSurfaceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)ioSurface);
                }
                VkResult vkUseIOSurfaceMVK_VkResult_return = (VkResult)0;
                vkUseIOSurfaceMVK_VkResult_return = vk->vkUseIOSurfaceMVK(image, ioSurface);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)ioSurface, sizeof(uint8_t));
                vkStream->write(&vkUseIOSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUseIOSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkUseIOSurfaceMVK_VkResult_return, image, ioSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetIOSurfaceMVK:
            {
                android::base::beginTrace("vkGetIOSurfaceMVK decode");
                VkImage image;
                void** pIOSurface;
                uint64_t cgen_var_860;
                memcpy((uint64_t*)&cgen_var_860, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_860));
                // Begin manual dispatchable handle unboxing for pIOSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIOSurface, sizeof(void*));
                memcpy((void**)pIOSurface, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetIOSurfaceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)pIOSurface);
                }
                vk->vkGetIOSurfaceMVK(image, pIOSurface);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pIOSurface, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetIOSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, image, pIOSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
            case OP_vkQueueFlushCommandsGOOGLE:
            {
                android::base::beginTrace("vkQueueFlushCommandsGOOGLE decode");
                VkQueue queue;
                VkCommandBuffer commandBuffer;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_861;
                memcpy((uint64_t*)&cgen_var_861, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_861));
                // No unbox for commandBuffer
                uint64_t cgen_var_862;
                memcpy((uint64_t*)&cgen_var_862, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_862));
                memcpy((VkDeviceSize*)&dataSize, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueFlushCommandsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)commandBuffer, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                m_state->on_vkQueueFlushCommandsGOOGLE(&m_pool, queue, commandBuffer, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueFlushCommandsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, commandBuffer, dataSize, pData);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
#endif
            default:
            {
                m_pool.freeAll();
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    if (m_forSnapshotLoad)
    {
        m_state->clearCreatedHandlesForSnapshotLoad();
    }
    m_pool.freeAll();
    return ptr - (unsigned char*)buf;;
}


