# "Cereal": generator for Vulkan drivers - Overview

Cereal consists of all necessary components for doing Vulkan driver development
for the Android Emulator.

It generates code that is intended to live on both the guest and host, crossing
a VM boundary, but there is no explicit restriction there; it is possible to
use this to generate API wrappers / remoting generally.

## Generated targets:

All generated targets have some way of getting tested on host, but the final
purpose of them is as follows:

Guest code:

- Frontend (`guest/goldfish_vk_frontend`): The functions that are directly
  referenced by the Vulkan HAL in the guest. Includes validation.

Host code:

- (TODO) Decoder (`host/goldfish_vk_decoder`) Functions that take existing Vulkan API calls and convert them to be runnable on the host Vulkan driver, with some translation if necessary.

Common code:

- Marshaling (`guest/goldfish_vk_marshaling`): Functions specifically for
  transforming Vulkan structs to and from a serialized format.
- Testing (`guest/goldfish_vk_testing`): More autogenerated code that makes it
  easier to thoroughly test the other auto-generated code.

## Organization

The structure of Python modules is as follows:

### Top level

`cerealgenerator.py` has a subclass of OutputGenerator that is also registered in `genvk.py` as `cereal`. It is the main "entry point" to Cereal and uses the same interface as other Vulkan generators such as `cgenerator.py` and `validitygenerator.py`.

### `cereal` Module

`cereal/` is a module that contains definitions for the modules mentioned above (frontend, decoder, marshaling, testing). There are both definitions and common utility functions.

The definitions are contained in `cereal/` and are as follows:

- `wrapperdefs.py`: Definitions that need to be shared across generated modules. For example, the code for frontend needs to know the API prefixes and signatures for the marshaling code.
- `frontend.py`: Definition for the guest API frontend.
- `marshaling.py`: Definition for marshaling.
- `testing.py`: Definition for generating code to test the other generated code.

Utility functions in `cereal/common`:

- `vulkantypes.py`: Knows everything that is specifically about Vulkan types (disregarding code generation) and provides all relevant information about a particular type instance (a struct field or function parameter) or complex type definition (a struct or union, or an API signature). It provides the following classes / functions that are used throughout the rest of the code:
    - `VulkanType`: Describes a single primitive type. It optionally carries information about the name of the struct field or function parameter.
    - `VulkanCompoundType`: Describes a compound type (a struct or union). Fields are represented in a list `members` which is a list of `VulkanType`.
    - `VulkanAPI`: Describes an API signature in terms of its name, return type, and parameters. Return type and parameters are represented as `VulkanType`'s.
    - `iterateVulkanType`: When we want to do something for all fields of a struct or all parameters of an API call, it's easy to repeatedly write code that checks properties of the `VulkanType` involved. This function makes it much easier by abstracting those checks away. It is a function that takes another object, `forEachType`, and depending on what `VulkanType` was visited, calls a corresponding callback.

- `codegen.py`: Knows everything about generating C++ code from the classes in `vulkantypes.py`.    - Provides the class `Module` which represents a C++ .cpp / .h, and handles actual writing to the files.
    - Provides the class `Codegen` which makes it easier to generate C++ code by automatically handling code indentation, generating C type declarations, and functions that make it easier to recover the proper struct access expressions and field length expressions from `VulkanType`'s.
